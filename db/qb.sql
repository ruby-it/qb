-- MySQL dump 9.11
--
-- Host: localhost    Database: qb_development
-- ------------------------------------------------------
-- Server version	4.0.24_Debian-10ubuntu2-log

--
-- Table structure for table `authors`
--

CREATE TABLE `authors` (
  `id` int(11) NOT NULL auto_increment,
  `name` varchar(255) default NULL,
  `ip` varchar(255) default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB;

--
-- Dumping data for table `authors`
--

INSERT INTO `authors` VALUES (15,'Ruby Fan','127.0.0.1');
INSERT INTO `authors` VALUES (16,'il gruppo','256.256.256.256');

--
-- Table structure for table `pages`
--

CREATE TABLE `pages` (
  `id` int(11) NOT NULL auto_increment,
  `title` varchar(255) default NULL,
  `created_at` datetime default NULL,
  `updated_at` datetime default NULL,
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB;

--
-- Dumping data for table `pages`
--

INSERT INTO `pages` VALUES (13,'Wiki','2005-11-03 10:16:11','2005-11-25 12:27:22');
INSERT INTO `pages` VALUES (15,'Documentazione','2005-11-03 19:13:32','2005-11-03 19:13:37');
INSERT INTO `pages` VALUES (16,'Progetti','2005-11-03 19:19:56','2005-11-03 19:25:49');
INSERT INTO `pages` VALUES (17,'perchÃ© ci piace ruby','2005-11-03 19:43:26','2005-11-03 21:54:19');
INSERT INTO `pages` VALUES (28,'Il gruppo','2005-11-25 12:27:42','2005-11-25 12:39:25');
INSERT INTO `pages` VALUES (29,'FormaLambda','2005-11-25 12:39:50','2005-11-25 12:39:50');
INSERT INTO `pages` VALUES (31,'5 Righe Wiki','2005-11-25 13:01:15','2005-11-25 13:01:15');
INSERT INTO `pages` VALUES (32,'Andrea  Abelli','2005-11-25 13:01:15','2005-11-25 13:01:15');
INSERT INTO `pages` VALUES (33,'BLUB Paradox','2005-11-25 13:01:15','2005-11-25 13:01:15');
INSERT INTO `pages` VALUES (34,'Bowling','2005-11-25 13:01:15','2005-11-25 13:01:15');
INSERT INTO `pages` VALUES (37,'Cercare Una Stringa In Un Altra','2005-11-25 13:01:15','2005-11-25 13:01:15');
INSERT INTO `pages` VALUES (38,'Client SOAP da WSDL','2005-11-25 13:01:15','2005-11-25 13:01:15');
INSERT INTO `pages` VALUES (39,'Classi  a Runtime  in Ruby  e Python','2005-11-25 13:01:15','2005-11-25 13:01:15');
INSERT INTO `pages` VALUES (40,'Client SOAP','2005-11-25 13:01:15','2005-11-25 13:01:15');
INSERT INTO `pages` VALUES (41,'Client XMLRPC','2005-11-25 13:01:15','2005-11-25 13:01:15');
INSERT INTO `pages` VALUES (42,'Collaborazione siforge','2005-11-25 13:01:15','2005-11-25 13:01:15');
INSERT INTO `pages` VALUES (43,'Contare Linee Parole Caratteri','2005-11-25 13:01:15','2005-11-25 13:01:15');
INSERT INTO `pages` VALUES (44,'ConTest','2005-11-25 13:01:15','2005-11-25 13:01:15');
INSERT INTO `pages` VALUES (45,'Convertire Fine Linea','2005-11-25 13:01:15','2005-11-25 13:01:15');
INSERT INTO `pages` VALUES (46,'CookBook','2005-11-25 13:01:15','2005-11-25 13:01:15');
INSERT INTO `pages` VALUES (47,'Creare Enumerable','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (48,'Currying','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (49,'Documentazione','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (50,'Duplicare Un Oggetto','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (51,'Eliminare Tab','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (52,'Estrarre URL','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (53,'Eliminare Duplicati','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (54,'Escape Di Caratteri Speciali','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (55,'Espressioni Regolari Alternanza','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (56,'Espressioni Regolari Basi','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (57,'Espressioni Regolari Ripetizioni','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (61,'Filtrare con select e reject','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (62,'Forma Lambda','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (63,'Funzionale Map','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (64,'Gabriele Renzi','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (65,'Generare XML con Dom','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (66,'Giovanni Corriga','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (67,'Gui con Tk','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (68,'Guide In Inglese','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (69,'Guide In Italiano','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (70,'Hash Infinito','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (71,'Hash JavaScript-like','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (72,'Hash Python-like','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (79,'inf','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (80,'Inizializzazione Condizionale','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (81,'Iterare In Parallelo','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (82,'Iterare Sequenze','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (83,'Iteratori Esterni','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (84,'Iteratori Personalizzati','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (85,'Leggere File Compressi','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (86,'Leggere File un Paragrafo per volta','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (87,'Leggere Metadati da File','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (89,'Links','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (92,'Luigi Panzeri','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (94,'Marshall','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (95,'Metodi che sembrano Keyword','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (96,'Mixin','2005-11-25 13:01:16','2005-11-25 13:01:16');
INSERT INTO `pages` VALUES (165,'Multiplexer','2005-11-25 13:01:17','2005-11-25 13:01:17');
INSERT INTO `pages` VALUES (166,'Nuby Quiz  Giugno  2004','2005-11-25 13:01:17','2005-11-25 13:01:17');
INSERT INTO `pages` VALUES (167,'Numeri Complessi','2005-11-25 13:01:17','2005-11-25 13:01:17');
INSERT INTO `pages` VALUES (168,'Oggetti Proc e Method','2005-11-25 13:01:17','2005-11-25 13:01:17');
INSERT INTO `pages` VALUES (169,'On Lisp On Ruby','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (171,'Ordinare Un File','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (173,'Ottenere Ruby','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (182,'Persone','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (183,'Piergiuliano Bossi','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (184,'Progetti','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (185,'Programming Ruby','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (186,'Prova','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (188,'Quiz Agosto 2004','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (189,'Quiz  Aprile  2003','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (190,'Quiz  Febbraio  2003','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (191,'Quiz  Giugno  2004','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (192,'Quiz  Maggio  2004','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (193,'Quiz  Marzo  2003','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (194,'Quiz  Ottobre  2004','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (195,'RDoc','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (197,'Reflection','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (198,'Rimuovere Dir','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (200,'Ru4Py Libs','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (201,'Ruby ed Emacs','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (202,'Ruby Language Reference Manual','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (204,'Ruby For Javanese','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (205,'Ruby For Pythonista','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (206,'Ruby Haiku','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (207,'Ruby Quiz  del mese','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (208,'Scuse Frequenti','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (210,'Singleton Class','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (211,'Soluzione Aprile 2003 di Gabriele Renzi','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (212,'Soluzione Aprile 2003 di Luigi Panzeri','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (213,'soluzione febbraio 2003 di gabriele renzi','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (214,'Soluzione Febbraio 2003 di Gabriele Renzi','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (215,'Soluzione  Febbraio 2003 di Kirash','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (216,'Soluzione  Febbraio  2003 di Massimiliano  Mirra','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (217,'Soluzione  Marzo  2003 di Luigi  Panzeri','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (218,'Spezzare Path File','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (219,'Statistica Parole','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (220,'Stato delle Traduzioni','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (221,'Stefano Zamprogno','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (223,'Trovare Parole Ripetute','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (224,'Usare Object Space','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (225,'Usare Pipe e Fork','2005-11-25 13:01:18','2005-11-25 13:01:18');
INSERT INTO `pages` VALUES (226,'Word Wrap','2005-11-25 13:01:18','2005-11-25 13:01:18');

--
-- Table structure for table `revisions`
--

CREATE TABLE `revisions` (
  `id` int(11) NOT NULL auto_increment,
  `page_id` int(11) default NULL,
  `author_id` int(11) default NULL,
  `created_at` datetime default NULL,
  `body` text,
  PRIMARY KEY  (`id`)
) ENGINE=InnoDB;

--
-- Dumping data for table `revisions`
--

INSERT INTO `revisions` VALUES (30,17,5,'2005-11-03 19:44:37',' MITICO FUNZIONA UTF-8 NEI TITOLI\r\nLorem ipsum dolor sit amet, consectetuer adipiscing elit. Quisque ac purus sed nulla cursus facilisis. Morbi a nisl id lacus fringilla elementum. Praesent faucibus adipiscing massa. Fusce sit amet nisi ut risus dictum egestas. Vivamus at velit eget pede laoreet viverra. Sed ornare leo et turpis. Sed convallis nisi ut lorem. Sed libero mi, ultricies in, euismod eu, sollicitudin id, libero. Sed commodo, purus at congue fermentum, tellus leo pharetra nisi, at tincidunt quam felis in nibh. Quisque porta scelerisque odio.\r\n\r\nLorem ipsum dolor sit amet, consectetuer adipiscing elit. Nullam elit magna, vehicula at, aliquam nec, convallis eu, est. Phasellus nonummy, nisl vitae congue tempus, nisi pede feugiat justo, id volutpat lacus risus ac tellus. Ut felis. Ut non nisl nec nulla rhoncus adipiscing. Curabitur commodo. In a enim vitae nunc cursus porta. Maecenas consequat libero eu turpis. Sed arcu est, consectetuer nec, rutrum sit amet, porta ut, nulla. Aliquam enim ipsum, interdum quis, convallis et, elementum a, ante. In a purus. Praesent a nunc. Nulla facilisi. In gravida accumsan diam. Duis faucibus, pede at ultricies feugiat, lectus nulla mattis lacus, sit amet aliquam sapien orci sed leo. Aenean sed risus. Nunc et libero. Suspendisse ac magna.\r\n\r\nCurabitur magna. Phasellus lectus. Ut molestie euismod odio. Donec lobortis dui nec odio. Curabitur vehicula consequat metus. Sed quis ante id justo vulputate lacinia. Duis arcu. Nam ipsum lorem, pharetra eu, tincidunt in, commodo non, sapien. Curabitur vulputate fermentum velit. Cras vitae nulla. Mauris commodo, diam ut tincidunt vehicula, risus magna placerat ligula, vel lobortis lacus ante quis tortor. Suspendisse potenti. Aliquam dapibus varius nulla. Praesent malesuada mi et mauris. Praesent dui. Maecenas porttitor condimentum arcu. Vivamus rhoncus imperdiet urna.\r\n\r\nIn enim massa, adipiscing eget, vulputate at, porta quis, magna. Cras eu nulla gravida tortor sagittis bibendum. In malesuada ornare ipsum. Phasellus auctor dignissim velit. Vestibulum rutrum. Praesent pulvinar, augue sit amet tempor porta, magna justo molestie lectus, vel dignissim leo erat ut turpis. Maecenas mattis vehicula pede. Ut tellus sem, rutrum sit amet, aliquet faucibus, ultricies non, ipsum. In pellentesque, lectus at tempor blandit, dui pede pulvinar mauris, id aliquet nunc eros vel lacus. Vestibulum at elit. Ut vulputate auctor neque. Praesent urna odio, tristique id, blandit sit amet, gravida non, nunc. In nec purus. Pellentesque varius semper lorem. Nunc massa tellus, volutpat consectetuer, tincidunt id, cursus sed, leo. Nulla non elit non nunc venenatis dignissim. Sed dolor. Mauris pretium, quam vitae rhoncus porta, lacus sapien mollis arcu, sed condimentum nisl odio in turpis. ');
INSERT INTO `revisions` VALUES (31,13,5,'2005-11-03 19:46:45','Questa Ã¨ la prima pagina del wiki \r\n\r\nclicca su Recently revised per vedere le ultime pagine modificate ');
INSERT INTO `revisions` VALUES (37,17,6,'2005-11-03 21:54:19',' MITICO FUNZIONA UTF-8 NEI TITOLI\r\nLorem ipsum dolor sit amet, consectetuer adipiscing elit. Quisque ac purus sed nulla cursus facilisis. Morbi a nisl id lacus fringilla elementum. Praesent faucibus adipiscing massa. Fusce sit amet nisi ut risus dictum egestas. Vivamus at velit eget pede laoreet viverra. Sed ornare leo et turpis. Sed convallis nisi ut lorem. Sed libero mi, ultricies in, euismod eu, sollicitudin id, libero. Sed commodo, purus at congue fermentum, tellus leo pharetra nisi, at tincidunt quam felis in nibh. Quisque porta scelerisque odio.\r\n\r\nLorem ipsum dolor sit amet, consectetuer adipiscing elit. Nullam elit magna, vehicula at, aliquam nec, convallis eu, est. Phasellus nonummy, nisl vitae congue tempus, nisi pede feugiat justo, id volutpat lacus risus ac tellus. Ut felis. Ut non nisl nec nulla rhoncus adipiscing. Curabitur commodo. In a enim vitae nunc cursus porta. Maecenas consequat libero eu turpis. Sed arcu est, consectetuer nec, rutrum sit amet, porta ut, nulla. Aliquam enim ipsum, interdum quis, convallis et, elementum a, ante. In a purus. Praesent a nunc. Nulla facilisi. In gravida accumsan diam. Duis faucibus, pede at ultricies feugiat, lectus nulla mattis lacus, sit amet aliquam sapien orci sed leo. Aenean sed risus. Nunc et libero. Suspendisse ac magna.\r\n\r\nCurabitur magna. Phasellus lectus. Ut molestie euismod odio. Donec lobortis dui nec odio. Curabitur vehicula consequat metus. Sed quis ante id justo vulputate lacinia. Duis arcu. Nam ipsum lorem, pharetra eu, tincidunt in, commodo non, sapien. Curabitur vulputate fermentum velit. Cras vitae nulla. Mauris commodo, diam ut tincidunt vehicula, risus magna placerat ligula, vel lobortis lacus ante quis tortor. Suspendisse potenti. Aliquam dapibus varius nulla. Praesent malesuada mi et mauris. Praesent dui. Maecenas porttitor condimentum arcu. Vivamus rhoncus imperdiet urna.\r\n\r\nIn enim massa, adipiscing eget, vulputate at, porta quis, magna. Cras eu nulla gravida tortor sagittis bibendum. In malesuada ornare ipsum. Phasellus auctor dignissim velit. Vestibulum rutrum. Praesent pulvinar, augue sit amet tempor porta, magna justo molestie lectus, vel dignissim leo erat ut turpis. Maecenas mattis vehicula pede. Ut tellus sem, rutrum sit amet, aliquet faucibus, ultricies non, ipsum. In pellentesque, lectus at tempor blandit, dui pede pulvinar mauris, id aliquet nunc eros vel lacus. Vestibulum at elit. Ut vulputate auctor neque. Praesent urna odio, tristique id, blandit sit amet, gravida non, nunc. In nec purus. Pellentesque varius semper lorem. Nunc massa tellus, volutpat consectetuer, tincidunt id, cursus sed, leo. Nulla non elit non nunc venenatis dignissim. Sed dolor. Mauris pretium, quam vitae rhoncus porta, lacus sapien mollis arcu, sed condimentum nisl odio in turpis. ');
INSERT INTO `revisions` VALUES (51,13,13,'2005-11-23 23:11:27','Questa Ã¨ la prima pagina del wiki \r\n\r\nclicca su Recently revised per vedere le ultime pagine modificate [[come questa]]');
INSERT INTO `revisions` VALUES (53,NULL,9,'2005-11-24 11:38:07','Lovely voices!');
INSERT INTO `revisions` VALUES (73,13,15,'2005-11-25 12:27:22','Questa Ã¨ la prima pagina del wiki \r\n\r\nUn wiki Ã¨ un sistema che permette di pubblicare e modificare pagine a tutti gli utenti. \r\nSe volete fare qualche tentativo e sperimentare con la sintassi potete andare alla [[prova|pagina di prova]].\r\n\r\nAlcuni dei percorsi possibili nel wiki sono:\r\n\r\n* [[Il gruppo]]\r\n* [[Documentazione]]\r\n* [[CookBook]]\r\n* [[RubyHaiku]]\r\n* [[Link]]\r\n* [[Persone]]\r\n* [[Progetti]]\r\n* [[Ruby ed Emacs]]\r\n* [[RubyQuiz del Mese]]\r\n');
INSERT INTO `revisions` VALUES (74,28,15,'2005-11-25 12:27:47',' proba');
INSERT INTO `revisions` VALUES (75,28,15,'2005-11-25 12:39:06','Il gruppo utenti ruby italia/italian ruby user group esiste dal 2003, per riunire le persone di lingua italia interessate a questo fantastico linguaggio in un unico punto, dato che eravamo in pochi. \r\n\r\nCon il tempo, ruby sta acquistando sempre piÃ¹ notorietÃ  specialmente grazie a [[RubyOnRails]], ma anche grazie a progetti come \"Alexandria\"http://alexandria.rubyforge.org, \"Typo\":http://typo.leetsoft.com/trac/ e tanti altri. \r\n\r\nOvviamente per noi Ã¨ facile spiegarci il perchÃ©: ruby Ã¨ un linguaggio che unisce la tradizione degli script UNIX (immediatezza, grande espressivitÃ , ottima interazione con il sistema) alle idee piÃ¹ interessanti provenienti da Lisp e Smalltalk (oggetti, [[FormaLambda|closure]]).\r\n\r\nParteciapre alla vita del gruppo Ã¨ semplice: iscriviti alla \"mailing list\":http://lists.ruby-it.org/mailman/listinfo/ml, \r\ndove potrai ricevere e dare aiuto, proporre un progetto etc..\r\nOppure puoi venire a fare quattro chiacchiere su [[irc]], o aggiungere una pagina al wiki, o magari semplicemente correggere una di quelle dove abbiamo scritto strafalcioni.\r\n\r\nIn ogni caso, benvenuto a bordo! ');
INSERT INTO `revisions` VALUES (76,28,15,'2005-11-25 12:39:25','Il gruppo utenti ruby italia/italian ruby user group esiste dal 2003, per riunire le persone di lingua italia interessate a questo fantastico linguaggio in un unico punto, dato che eravamo in pochi. \r\n\r\nCon il tempo, ruby sta acquistando sempre piÃ¹ notorietÃ  specialmente grazie a [[RubyOnRails]], ma anche grazie a progetti come \"Alexandria\":http://alexandria.rubyforge.org, \"Typo\":http://typo.leetsoft.com/trac/ e tanti altri. \r\n\r\nOvviamente per noi Ã¨ facile spiegarci il perchÃ©: ruby Ã¨ un linguaggio che unisce la tradizione degli script UNIX (immediatezza, grande espressivitÃ , ottima interazione con il sistema) alle idee piÃ¹ interessanti provenienti da Lisp e Smalltalk (oggetti, [[FormaLambda|closure]]).\r\n\r\nParteciapre alla vita del gruppo Ã¨ semplice: iscriviti alla \"mailing list\":http://lists.ruby-it.org/mailman/listinfo/ml, \r\ndove potrai ricevere e dare aiuto, proporre un progetto etc..\r\nOppure puoi venire a fare quattro chiacchiere su [[irc]], o aggiungere una pagina al wiki, o magari semplicemente correggere una di quelle dove abbiamo scritto strafalcioni.\r\n\r\nIn ogni caso, benvenuto a bordo! ');
INSERT INTO `revisions` VALUES (77,30,16,'2005-11-25 13:01:15','h1.  5righewiki\r \nvedi 5RigheWiki\r\n[ ! poker games  | http://poker-games.mynet-poker.com/ ] 6/13/2005 17:57:57%%%\r\n[ ! party poker  | http://party-poker.mynet-poker.com/ ] 6/13/2005 17:57:57%%%\r\n[ ! pacific poker  | http://pacific-poker.mynet-poker.com/ ] 6/13/2005 17:57:57%%%\r\n[ ! empire poker  | http://empire-poker.mynet-poker.com/ ] 6/13/2005 17:57:57%%%\r\n[ ! poker rules  | http://poker-rules.mynet-poker.com/ ] 6/13/2005 17:57:57%%%\r\n[ ! texas hold em  | http://texas-hold-em.mynet-poker.com/ ] 6/13/2005 17:57:57%%%\r\n[ ! free poker  | http://free-poker.mynet-poker.com/ ] 6/13/2005 17:57:57%%%\r\n[ ! poker  | http://poker.mynet-poker.com/ ] 6/13/2005 17:57:57%%%\r\n[ ! texas holdem  | http://texas-holdem.mynet-poker.com/ ] 6/13/2005 17:57:57%%%\r\n[ ! online poker  | http://online-poker.mynet-poker.com/ ] 6/13/2005 17:57:57%%%\r\n');
INSERT INTO `revisions` VALUES (78,31,16,'2005-11-25 13:01:15','h1.  5RigheWiki\r \neccolo:\r\n #!/path/per/ruby -r cgi\r\n H=\'HomePage\';B=\'w7.cgi?n=%s\';p=(c=CGI.new(\'html4\')).params;n=p[\'n\'][0]||H\r\n d=p[\'d\'][0];t=IO.read(n)rescue \'\';open(n,\'w\').puts(t=CGI.escapeHTML(d)) if d\r\n c.out{c.h1{n}+c.a(B%H){H}+c.pre{ t.gsub(/([A-Z]\\w+){2}/){|w| c.a(B%w){w}}}+\r\n c.form(\"get\"){c.textarea(\'d\'){t}+c.hidden(\'n\',n)+c.submit}}\r\n\r\n\r\n\r\nin forma leggermente piu\' leggibile e\' questo:\r\n\r\n #!/path/per/ruby.exe -r cgi\r\n H=\'HomePage\' # La prima pagina\r\n B=\'wk5.cgi?nome=%s\' # Il link base, wk5.cgi e\' il file\r\n c=CGI.new(\'html4\')\r\n para=c.params \r\n # se il parametro non esiste, e vale nil, \r\n # viene asegnato H\r\n nome=(para[\'nome\'][0] or H) \r\n\r\n # se stiamo scrivendo la pagina passiamo anche i dati\r\n data=para[\'data\'][0]\r\n # leggiamo il file, se non esiste catturiamo\r\n # l\'eccezione e usiamo unoi spazio come testo\r\n txt=IO.read(nome) rescue \'\'  \r\n\r\n # se stiamo scrivendo data != nil\r\n if data\r\n  txt=CGI.escapeHTML(data) #puliamo il codice\r\n  # e lo scriviamo\r\n  # pessimo esempio: il file andrebbe chiuso :)\r\n  open(nome,\'w+\').puts( txt) if  data\r\n end\r\n # buttiamo sulla connessione:\r\n c.out{ # header http vari\r\n 	c.h1{n}+  # nomepagina\r\n	c.a(B%H){H}+ # B%H= w5.cgi?nome=QualcheNome\r\n	c.pre{ t.gsub(/([A-Z]\\w+){2}/){ |w| \r\n                 c.a(B%w){w}\r\n               }\r\n        }+ # il corpo della pagina\r\n	c.form(\"get\"){\r\n		c.textarea(\'d\'){t}+\r\n		c.hidden(\'n\',n)+\r\n		c.submit\r\n	}\r\n }\r\n\r\n\r\n');
INSERT INTO `revisions` VALUES (79,32,16,'2005-11-25 13:01:15','h1.  Andrea Abelli\r \n\r\n');
INSERT INTO `revisions` VALUES (80,33,16,'2005-11-25 13:01:15','h1.  BLUBParadox \n\nUn esempio inventato da [[Paul Graham|URL:http://www.paulgraham.com]] per spiegare \ncome mai a tanta gente non piace il LISP:\n\n\"[pensate a] un ipotetico linguaggio di nome Blub. Blub sta esattamente nel mezzo del continuum dell\'astrazione. Non e\' il linguaggio piu\' potente, ma e\' piu\' potente del Cobol o del linguaggio macchina.\n\nEd in effetti il nostro ipotetico programmatore Blub non userebbe mai nessuno dei due. Ovviamente non programmerebbe mai in linguaggio macchina. E\' a quello che servono i compilatori. e per quel che riguarda il Cobol, lui non riesce a capire come qualcuno posssa riuscire ad usarlo in qualche modo. Non ha nemmeno x (x e\' una feature di Blub a scelta).\n\nFinche\' il nostro  ipotetico programmatore Blub guarda verso  il basso nel continuum della potenza, sa che sta guardando verso il basso. I linguaggi meno potenti di Blub sono ovviamente meno potenti, perche\' gli mancano delle feature a cui e\' abituato. \nMa quando il nostro ipotetico programmatore Blub guarda nell\'altra direzione, piu\' in alto nel continuum della potenza, non riesce a capire che sta guardando in su. Cio\' che vede sono solamente linguaggistrani. Porbabilmente li considera piu\' o meno potenti quanto Blub, ma con un sacco di roba strana e incomprensibile messa in mezzo. Blub e\' abbastanza buono per lui, perche\' lui pensa in Blub.\"\n\nNota: imo un linguaggio non e\' quasi mai del tutto piu\' potente di un altro, ma puo\' avere cmq delle feature che l\'ipotetico Blubista non comprende, e che invece una volta capite sono potentissime. Blub non ha le [[lambda|FormaLambda]], quasi sicuramente.\n');
INSERT INTO `revisions` VALUES (81,34,16,'2005-11-25 13:01:15','h1.  Bowling\r \n\r\nh1. = Antefatto\r \n\r\nPoco prima di Natale (2004) Ron Jeffries pubblica sul suo sito una serie di articoli in cui implementa per l\'ennesima volta un sistema che calcola lo score di una partita di bowling. Il tutto prende le mosse dagli XP Immersion di zio Bob, ovvero anima e mente di [[ObjectMentor|URL:http://www.objectmentor.com]] ==> check [[URL:http://www.objectmentor.com/resources/articles/xpepisode.htm]]\r\n\r\nQuesta volta Ron Jeffries vuole ritornare a usare smalltalk, inizia a scrivere e contemporaneamente riceve feedback sulla mailing list XP. Per cui la serie di articoli si allunga:\r\n\r\n * [[Discovering Better Code: Bowling For Smalltalk|URL:http://www.xprogramming.com/xpmag/BowlingForSmalltalk.htm]]\r\n * [[DBC: Bowling For Smalltalk II|URL:http://www.xprogramming.com/xpmag/BowlingForSmalltalkII.htm]]\r\n * [[DBC: I Was Framed!|URL:http://www.xprogramming.com/xpmag/BowlingForSmalltalkIII.htm]]\r\n * [[DBC: Keep on Rollin\'|URL:http://www.xprogramming.com/xpmag/BowlingForSmalltalkIV.htm]]\r\n * [[DBC: With a Little Help From My Friends|URL:http://www.xprogramming.com/xpmag/BowlingForSmalltalkV.htm]]\r\n * [[DBC: Another Frame|URL:http://www.xprogramming.com/xpmag/BowlingForSmalltalkVI.htm]]\r\n * [[DBC: An Example Refactored|URL:http://www.xprogramming.com/xpmag/BowlingForSmalltalkRefactoring.htm]]\r\n * [[DBC: StreamBowlingGame|URL:http://www.xprogramming.com/xpmag/StreamBowlingGame.htm]]\r\n\r\nh1. = E ora ruby!\r \n\r\nMi sono subito detto: perche\' non seguire i suoi passi, uno alla volta, pero\' in ruby anziche\' smalltalk? Ebbene, ci sono riuscito, nonostante non avessi un refactoring browser (e naturalmente niente RubyLint, e niente sorgente di un metodo disponibile programmaticamente, ma quantomeno quest\'ultimo e\' un aspetto secondario). Per scrivere il codice e i test e rifattorizzare ho usato un po\' Eclipse (con RDT) e un po\' Arachno Ruby. Quest\'ultimo ha il pregio di essere piu\' leggero di Eclipse e per certi versi piu\' veloce, ma non sono mai riuscito a far funzionare il debugger; Eclipse invece ha un ottimo code completion e una buona integrazione con il debugger - e\' solo un po\' troppo _fat_.\r\n\r\nMi manca molto il refactoring browser, pero\' vabbe\'. Il search & replace di Arachno e\' molto carino, aiuta. Un po\' manca anche l\'assenza dei reference a un metodo.\r\n\r\nAlla fin fine ho rifattorizzato anche i test in un\'unica classe, con istanziazione parametrica della classe che implementa il calcolo vero e proprio (se segui gli articoli ne ottieni 3 versioni distinte). Comunque sia, leggetevi gli articoli, altrimenti quanto scrivo non ha molto senso.\r\n\r\n * test_bowling.rb\r\n\r\n    class TestBowling < Test::Unit::TestCase\r\n      def setup\r\n        @game = GAME.new\r\n      end\r\n      def test_all_gutters\r\n        20.times { @game.roll 0 }\r\n        assert_equal(0, @game.score)\r\n      end\r\n      def test_all_open\r\n        10.times { @game.roll 5; @game.roll 4 }\r\n        assert_equal(90, @game.score)\r\n      end\r\n      def test_spare\r\n        @game.roll 4\r\n        @game.roll 6\r\n        @game.roll 5\r\n        @game.roll 4\r\n        8.times { @game.roll 0; @game.roll 0 }\r\n        assert_equal(24, @game.score)\r\n      end\r\n      def test_strike\r\n        @game.roll 10\r\n        @game.roll 5\r\n        @game.roll 4\r\n        @game.roll 3\r\n        @game.roll 0\r\n        7.times { @game.roll 0; @game.roll 0 }\r\n        assert_equal(31, @game.score)\r\n      end\r\n      def test_perfect\r\n        12.times { @game.roll 10 }\r\n        assert_equal(300, @game.score)\r\n      end\r\n      def test_alternating\r\n        5.times { @game.roll 10; @game.roll 6; @game.roll 4 }\r\n        @game.roll 10\r\n        assert_equal(200, @game.score)\r\n      end\r\n      def test_complex_open\r\n        rolls = [1, 1,   1, 2,   2, 1,   2, 3,   3, 2,   1, 4,   4, 1,   1, 5,   5, 1,   1, 6]\r\n        rollSum = rolls.inject(0) {|sum, each| sum + each}\r\n        rolls.each {|i| @game.roll i}\r\n        assert_equal(rollSum, @game.score)\r\n      end\r\n    end\r\n\r\n * bowling.rb\r\n\r\n    require \'test/unit\'\r\n    require \'test_bowling\'\r\n    \r\n    class BowlingGame\r\n      def initialize\r\n        @rolls = []\r\n      end\r\n      def roll(pins)\r\n        @rolls.push pins\r\n      end\r\n      def score\r\n        frames.total_score\r\n      end\r\n      def frames\r\n        firstFrame = RackFrame.ten_frame_list\r\n        @rolls.each { |pins| firstFrame.roll pins}\r\n        firstFrame\r\n      end\r\n    end\r\n    \r\n    class RackFrame\r\n      def initialize\r\n        @state = :first_roll\r\n        @next = nil\r\n      end\r\n      def RackFrame.ten_frame_list\r\n        frame = RackFrame.new\r\n        9.times { frame = RackFrame.another(frame) }\r\n        frame\r\n      end\r\n      attr_reader :score\r\n      attr_accessor :next\r\n      def roll(pins)\r\n        send(@state, pins)\r\n      end\r\n      def RackFrame.another(aFrame)\r\n        frame = RackFrame.new\r\n        frame.next = aFrame\r\n        frame\r\n      end\r\n      def total_score\r\n        score + (@next.nil? ? 0 : @next.total_score)\r\n      end\r\n    \r\n      private\r\n      def first_roll(pins)\r\n        @score = pins\r\n        if @score == 10\r\n          @state = :first_strike_bonus\r\n        else\r\n          @state = :second_roll\r\n        end\r\n      end\r\n      def first_strike_bonus(pins)\r\n        @score += pins\r\n        next_roll pins\r\n        @state = :second_strike_bonus\r\n      end\r\n      def second_roll(pins)\r\n        @score += pins\r\n        if @score == 10\r\n          @state = :spare_bonus\r\n        else\r\n          @state = :satisfied\r\n        end\r\n      end\r\n      def second_strike_bonus(pins)\r\n        @score += pins\r\n        next_roll pins\r\n        @state = :satisfied\r\n      end\r\n      def spare_bonus(pins)\r\n        @score += pins\r\n        next_roll pins\r\n        @state = :satisfied\r\n      end\r\n      def satisfied(pins)\r\n        next_roll pins\r\n      end\r\n      def next_roll pins\r\n        @next.roll pins unless @next.nil?\r\n      end\r\n    end\r\n    \r\n    class TestFrame < Test::Unit::TestCase\r\n      def setup\r\n        @frame = RackFrame.ten_frame_list\r\n      end\r\n      def test_open\r\n        @frame.roll 4\r\n        @frame.roll 5\r\n        @frame.roll 1\r\n        @frame.roll 2\r\n        assert_equal(9, @frame.score)\r\n      end\r\n      def test_spare\r\n        @frame.roll 9\r\n        @frame.roll 1\r\n        @frame.roll 5\r\n        @frame.roll 4\r\n        assert_equal(15, @frame.score)\r\n      end\r\n      def test_spare_with_zero\r\n        @frame.roll 9\r\n        @frame.roll 1\r\n        @frame.roll 0\r\n        @frame.roll 4\r\n        assert_equal(10, @frame.score)\r\n      end\r\n      def test_strike\r\n        @frame.roll 10\r\n        @frame.roll 10\r\n        @frame.roll 10\r\n        @frame.roll 5\r\n        assert_equal(30, @frame.score)\r\n      end    \r\n      def test_frame_string\r\n        count = 0\r\n        currentFrame = @frame\r\n        until currentFrame.nil?\r\n          count += 1\r\n          currentFrame = currentFrame.next\r\n        end\r\n        assert_equal(10, count)\r\n      end\r\n      def test_ten_open_frames\r\n        10.times { @frame.roll 4; @frame.roll 3 }\r\n        assert_equal(70, @frame.total_score)\r\n      end\r\n      def test_second_frame\r\n        @frame.roll 5\r\n        @frame.roll 4\r\n        @frame.roll 3\r\n        @frame.roll 2\r\n        assert_equal(9, @frame.score)\r\n        assert_equal(5, @frame.next.score)\r\n      end\r\n      def test_perfect\r\n        12.times { @frame.roll 10 }\r\n        assert_equal(300, @frame.total_score)\r\n      end\r\n    end\r\n\r\n    TestBowling.const_set :GAME, BowlingGame\r\n\r\n * bowling2.rb\r\n\r\n    require \'test/unit\'\r\n    require \'test_bowling\'\r\n    \r\n    class BowlingGame2\r\n      def initialize\r\n        @rolls = []\r\n        @score = 0\r\n        @frameStart = 0\r\n      end\r\n      def roll(pins)\r\n        @rolls.push pins\r\n      end\r\n      \r\n      def score\r\n        number_of_frames.times {\r\n          @score += frame_score\r\n          update_frame_start\r\n        }\r\n        @score\r\n      end\r\n    \r\n      private\r\n      def number_of_frames\r\n        10\r\n      end\r\n      def all_pins_down\r\n        10\r\n      end\r\n      def frame_score\r\n        frame_score = roll1 + roll2\r\n        frame_score += roll3 if bonus_frame?\r\n        frame_score\r\n      end\r\n      def update_frame_start\r\n        @frameStart += strike? ? 1 : 2\r\n      end\r\n      def bonus_frame?\r\n        spare? || strike?\r\n      end\r\n      def roll1\r\n        @rolls[@frameStart]\r\n      end\r\n      def roll2\r\n        @rolls[@frameStart+1]\r\n      end\r\n      def roll3\r\n        @rolls[@frameStart+2]\r\n      end\r\n      def strike?\r\n        roll1 == all_pins_down\r\n      end\r\n      def spare?\r\n        roll1 < all_pins_down && roll1+roll2 == all_pins_down\r\n      end\r\n    end\r\n    \r\n    TestBowling.const_set :GAME, BowlingGame2\r\n    \r\n * bowling_stream.rb\r\n\r\n    require \'test/unit\'\r\n    require \'test_bowling\'  \r\n    \r\n    class StreamBowlingGame\r\n      def initialize\r\n        @rolls = []\r\n      end\r\n      def roll(pins)\r\n        @rolls.push pins\r\n      end\r\n      def score\r\n        @index = -1\r\n        total = 0\r\n        10.times { total += score_frame }\r\n        total\r\n      end\r\n      def next\r\n        @index += 1\r\n        @rolls[@index]\r\n      end\r\n    \r\n      private\r\n      def score_frame\r\n        if spare? \r\n          self.next + self.next + peek\r\n        elsif strike?   \r\n          self.next + peek + peek_second\r\n        else  \r\n          self.next + self.next\r\n        end \r\n      end\r\n      def spare?\r\n        peek + peek_second == 10\r\n      end\r\n      def strike?\r\n        peek == 10\r\n      end\r\n      def peek\r\n        @rolls[@index+1]\r\n      end\r\n      def peek_second\r\n        @rolls[@index+2]\r\n      end\r\n    end\r\n    \r\n    TestBowling.const_set :GAME, StreamBowlingGame\r\n');
INSERT INTO `revisions` VALUES (83,37,16,'2005-11-25 13:01:15','h1.  Cercare Una Stringa\r \n\r\nQuesto e\' il compito per cui sono state inventate le espressioni regolari, o @Regexp@. \r\nUsare le @Regexp@ e\' semplice, ma puo\' diventare molto complicato se si usano le loro caratteristiche piu\' potenti. \r\n\r\nLe espressioni regolari sono un argomento molto complesso, non sono completamente spiegate in questa pagina. Il nostro scopo e\' solo di individuare delle sottostringhe.\r\n\r\nIn generale, una regexp si crea in questo modo:\r\n >> rgx= /espressione/\r\n => /espressione/\r\n\r\no usando esplicitamente il costruttore della classe @Regexp@:\r\n >> rgx= Regexp.new \"espressione\"\r\n => /espressione/\r\n\r\nper verificare che una stringa sia contenuta in un altra si puo\' usare l\'operatore @=~@:\r\n\r\n >> \'la mia espressione\' =~ rgx\r\n => 7\r\n >> \'bau\' =~ rgx\r\n => nil\r\n\r\nCome vedete, l\'operatore restituisce l\'indice della stringa dove ha inizio l\'espressione rappresentata dalla @Regexp@, oppure @nil@. Dunque possiamo scrivere cose del genere:\r\n\r\n >> if \'ciao\'=~ /a/\r\n >>  p \'trovata una a\'\r\n >> end\r\n\r\nPossiamo usare le @Regexp@ anche in un modo piu\' \"ad oggetti\":\r\n\r\n >> /a/.match \'ciao\'\r\n => #<MatchData:0x27c9b90>\r\n >> /a/.match \'cio\'\r\n => nil\r\n\r\nQuel @MatchData@ e\' un oggetto speciale, che contiene al suo interno i valori trovati dal\'espressione. Se non viene trovato nulla, appare un @nil@, di nuovo, quindi vale la considerazione fatta prima.\r\nancora sui confronti: le @Regexp@ posseggono anche un operatore @===@ che viene usato nei confronti @case@:\r\n\r\n >> case \'ciao\'\r\n >>  when /k/\r\n >>   puts \'trovata k\'\r\n >>  when /z/\r\n >>   puts \'trovata z\'\r\n >>  when /a/\r\n >>   puts \'trovata a\'\r\n >> end\r\n trovata a\r\n => nil\r\n\r\n\r\n');
INSERT INTO `revisions` VALUES (84,38,16,'2005-11-25 13:01:15','h1.  Client SOAP da WSDL\r \n\r\nCreare un client SOAP a mano non e\' molto complesso. \r\nD\'altronde, esiste uno standard, detto WSDL, che ci permette di descrivere in un formato concettualmente semplice dei servizi SOAP.\r\n\r\nUna volta ottenuto il wsdl possiamo generare automaticamente un client.\r\nIn ruby, possiamo usare lo script @wsdl2ruby.rb@ per generare effettivamente del codice da manipolare, oppure possiamo usare una classe, @WSDLDriverFactory@ che ci permette di creare un client a runtime in modo incredibilmente semplice.\r\n\r\nPer questo esempio useremo un servizio trovato su [[xmethods.org|URL:http://www.xmethods.org]], che somiglia ai classici giochi a premi televisivi con domande a risposta multipla.\r\n\r\nProveremo il sistema direttamente da @IRB@, cercando di imparare dagli errori.\r\nLa prima cosa da fare e\' caricare @SOAP::WSDLDriverFactory@ e creare un driver:\r\n >> require \"soap/wsdlDriver\"\r\n => true\r\n >> url=\"http://java.rus.uni-stuttgart.de/quiz/quiz.wsdl\"\r\n => \"http://java.rus.uni-stuttgart.de/quiz/quiz.wsdl\"\r\n >> client = SOAP::WSDLDriverFactory.new(url).createDriver\r\n => #<SOAP::WSDLDriver:{http://www.themindelectric.com/wsdl/QuizService/}IQuizService>\r\n\r\nPiuttosto semplice, no?\r\nNel dettaglio quello che abbiamo fatto è:\r\n (1) caricare la classe @WSDLDriverFactory@\r\n (2) creare un oggetto Factory, cioe\' un oggetto che potra\' poi _fabbricare_ varie istanze di @WSDLDriver@\r\n     che usino quell\'url.\r\n (3) creare ( con @create@ ) uno di questi oggetti\r\n\r\n\r\nOra usiamo la potente [[Reflection]] di ruby per sapere quali sono i metodi interessanti di questo client:\r\n\r\n >> puts client.methods(false)\r\n checkCorrectAnswerById\r\n addNewEntry\r\n getRandomQuestionByDifficultyLevel\r\n getRandomQuestion\r\n getCorrectAnswerForQuestionById\r\n => nil\r\n\r\nMh.. @getRandomQuestion@ sembra interessante, proviamo a fare una prova:\r\n\r\n >> dom= client.getRandomQuestion\r\n => #<SOAP::Mapping::Object:0x2d65af8 @answerB=\"Space Balls\", @question=\"In what\r\n 80\'s movie will you find the following: a rocketship inside a house, blue grandp\r\n arents, and a talking pile of dung?\", @id=63, @difficultyLevel=16000, @answerC=\"\r\n The Ice Pirates\", @answerA=\"Weird Science\", @answerD=\"The Neverending Story\">\r\n\r\nSembra che abbiamo ottenuto una bella domanda :) a questo punto, avrete capito come funziona, vi faccio vedere un semplice client: \r\n require \"soap/wsdlDriver\"\r\n \r\n url=\"http://java.rus.uni-stuttgart.de/quiz/quiz.wsdl\"\r\n \r\n client = SOAP::WSDLDriverFactory.new(url).createDriver\r\n \r\n while true \r\n  d= client.getRandomQuestion\r\n  puts \'========\'\r\n  puts d.question\r\n  puts \'a: \'+d.answerA\r\n  puts \'b: \'+d.answerB\r\n  puts \'c: \'+d.answerC\r\n  puts \'d: \'+d.answerD\r\n  puts \'Premi invio per la risposta giusta..\'\r\n  gets\r\n  puts client.getCorrectAnswerForQuestionById(d.id)\r\n  puts \'vuoi proseguire?[s/n]\'\r\n  break unless gets.chomp==\'s\'\r\n end \r\n\r\nUn ultimo dettaglio: qualsiasi errore viene trasmesso come @SOAP::FaultError@ e potete gestirlo come una qualunque eccezione:\r\n >>  client.getCorrectAnswerForQuestionById 1000\r\n SOAP::FaultError: The Id for the Question you provided doesn\'t exist witin this\r\n service.\n');
INSERT INTO `revisions` VALUES (85,39,16,'2005-11-25 13:01:15','h1.  Classi a Runtime \r \nh1. = (in Ruby e Python)\r \n\r\n\r\nNel messaggio _<42121a81$0$32333$5fc30a8@news.tiscali.it>_ su comp.lang.python, l\'autore parla della possibilita\' di creare classi a runtime in python o ruby:\r\n\r\n\r\n\r\n In Python, la creazione di una classe e\' gia\' di per se dinamica:\r\n\r\n class miaclasse: pass\r\n\r\n In qualunque momento si puo\' creare una classe, ad es. da una funzione.\r\n In ruby, essendo le classi dichiarate costanti, in runtime bisogna creare una classe   \r\n ricorrendo all\'istanza di Class:\r\n\r\n miaclasse = Class.new()\r\n\r\n Il problema e\' che facendo miaclasse.new() non si avra\' una instanza di miaclasse ma di \r\n Class. Quindi ribadisco la mia opinioni sulla dinamicita\' del Python sulle classi.\r\n\r\nAndiamo per gradi. In ruby, diversamente da python, esiste un concetto di \"costante\". \r\nIn realta\' e\' sempre possibile riassegnare una costante, a meno che non si imposti un _safe level_ che lo proibisca. \r\nCome si definisce una costante? Semplice, le si da un nome maiuscolo, ovvero si adotta come regola quella che e\' una convenzione in molti altri linguaggi.\r\nOvviamente le costanti devono essere create staticamente, e quindi non e\' possibile dichiararle all\'interno di strutture di controllo come metodi o @if-then-else@.\r\n\r\nInoltre, in ruby, diversamente da python, c\'e\' una restrizione sulla creazione di classi e moduli, essi devono essere costanti. \r\n\r\nMa queste restrizioni esistono solo a livello sintattico, e non strutturale. \r\nPerche\'? Perche\' ruby, in generale, _suggerisce_ un certo modo di programmare, ma quasi mai lo _impone_.\r\n\r\nDunque dovendo creare una classe in un metodo, si puo\'; semplicemente chiedere alla classe delle classi @Class@ di darcene una:\r\n >> c=Class.new\r\n => #<Class:0x2be89e0>\r\n\r\nfacile, creiamo ora un\'istanza:\r\n >> i=c.new\r\n => #<#<Class:0x2be89e0>:0x2be7600>\r\n\r\nbrutto ouput, vero?\r\nin realta\' e\' abbastanza normale: l\'identita\'; della classe non puo\' essere determinata, e quindi corrisponde semplicemente alla rappresentazione di oggetto qualunque, ovvero il risultato della prima operazione.\r\n\r\ne viene usato per costruire la stringa seguente, che altro non e\' che:\r\n #<rappresentazione_classe:id_oggetto>\r\n\r\ndunque, facciamo una prova finale:\r\n\r\n >> def dammi_una_classe_e_un_oggetto\r\n >>  c=Class.new\r\n >>  i=c.new\r\n >>  return c,i\r\n >> end\r\n => nil\r\n >> classe,oggetto=dammi_una_classe_e_un_oggetto()\r\n => [#<Class:0x2bd91e8>, #<#<Class:0x2bd91e8>:0x2bd91b8>]\r\n >> oggetto.class == classe.class\r\n => false\r\n >> oggetto.class == classe\r\n => true\r\n >> classe.class\r\n => Class\r\n >> oggetto.class\r\n => #<Class:0x2bd91e8>\r\n\r\nInsomma, nessun problema potete crearvi le classi dove vi pare :)  \n');
INSERT INTO `revisions` VALUES (86,40,16,'2005-11-25 13:01:15','h1.  ClientSOAP\r \n\r\nSOAP e\' un protocollo che permette di realizzare servizi accessibili da remoto, basato su XML e HTTP, e usabile quindi da quasi ogni piattaforma e linguaggio.\r\nRuby ha avuto per molto tempo un\'implementazione SOAP, detta [[SOAP4R|URL:http://rrr.jin.gr.jp/doc/soap4r/RELEASE_en.html]], che e\' stata integrata nella distribuzione dell\'interprete base dalla versione 1.8.1.\r\nUsando SOAP4R si possono realizzare client e server SOAP, manipolare file WSDL, e grazie ai binding con openssl usare servizi sicuri con HTTPS. \r\n\r\n\r\nScrivere un client SOAP in ruby e\' davvero semplice. \r\nUn buon posto per cercare servizi gratuiti e disponibili a tutti e\' xmethods.org.\r\n\r\nVediamo un esempio:\r\n require \'soap/rpc/driver\'\r\n server = \"http://services.xmethods.com/soap\"\r\n namespace = \"urn:xmethods-delayed-quotes\"\r\n client = SOAP::RPC::Driver.new( server, namespace )\r\n client.add_method( \"getQuote\", \"symbol\" )\r\n azioni = [\"RHAT\", \"IBM\", \"MSFT\", \"AMR\", \"LNUX\", \"NT\", \"TSG\"]\r\n\r\n puts \"Prezzi Azioni\"\r\n puts \"================\"\r\n\r\n azioni.sort.each do |azione|\r\n   printf(\"%6s %8.3f\\n\", azione, client.getQuote(azione))\r\n end\r\n\r\nQuesto semplice script ci permette di conoscere i valori di mercato di alcune societa\'.\r\nCome funziona?\r\nSemplice, un @Driver@), cioe\' un meccanismo che ci permette di accedere al servizio, viene creato usando un url ed un identificatore univoco ( _urn_ ).\r\n\r\nSubito dopo aggiungiamo all\'oggetto un metodo, disponibile sul server, che rappresenta la richiesta che vogliamo effettuare. \r\nPer aggiungere il metodo dobbiamo usare il suo nome (il primo parametro) ed il tipo di parametro che noi dovremo passargli (@symbol@ in questo caso, in sostanza e\' una stringa). Queste sono tutte informazioni che deve fornire chi crea il servizio, non dovete inventarle :) \r\n\r\nA questo punto non ci rimane che richiamare questo metodo con il parametro che vogliamo, in questo caso lo chiamiamo un po\' di volte con gli identificatri delle varie societa\'.\r\nInfine, ordiniamo il tutto e stampiamo a schermo:\r\n Prezzi Azioni\r\n ================\r\n   AMR   15.360\r\n   IBM   96.250\r\n  LNUX    3.748\r\n  MSFT   26.460\r\n    NT    7.660\r\n  RHAT   18.490\r\n   TSG   22.500\r\n\r\nUn\'ultima nota: usando un WSDL, tutto questo puo\' essere automatizzato (vedere [[ClientSOAPDaWSDL]] per maggiori info)\n');
INSERT INTO `revisions` VALUES (87,41,16,'2005-11-25 13:01:15','h1.  ClientXMLRPC\r \n\r\n_basato su perl cookbook 18.12_\r\n\r\nI servizi xmlrpc sono piuttosto duffusi su internet. In effetti, molti ritengono xmlrpc migliore di SOAP, in quanto si tratta di un protocollo incredibilmente piu\' semplice, ed in grado comunque di coprire il 99% dei casi in cui si usa SOAP.\r\n\r\nCome si scrive un client xmlrpc ?\r\nIn ruby in pochi passi. Anzitutto dovete sapere che ruby ha gia\' un modulo per gestire xmlrpx nella sua distribuzione standard.\r\n\r\nL\'uso e\' banale:\r\n\r\n >> require \"xmlrpc/client\"\r\n => true\r\n >> client = XMLRPC::Client.new( \"xmlrpc-c.sourceforge.net\", \"/api/sample.php\")\r\n => #<XMLRPC::Client:0x2abae38 @create=nil, @port=80, @http=#<Net::HTTP xmlrpc-c.\r\n sourceforge.net:80 open=false>, @proxy_host=nil, @http_last_response=nil, @parse\r\n r=nil, @timeout=30, @path=\"/api/sample.php\", @auth=nil, @password=nil, @http_hea\r\n der_extra=nil, @use_ssl=false, @host=\"xmlrpc-c.sourceforge.net\", @user=nil, @pro\r\n xy_port=nil, @cookie=nil>\r\n >> res = client.call(\"sample.sumAndDifference\", 5, 3)\r\n => {\"difference\"=>2, \"sum\"=>8}\r\n >> result[\"sum\"]\r\n => 8\r\n >> result[\"difference\"]\r\n => 2 \r\n\r\n\r\nSpiegazione:\r\n (1) prima carichiamo la libreria, in particolare la classe @Client@\r\n (2) creiamo il client, passandogli l\'host dove si trova il servizio, e l\'indirizzo\r\n (3) chiamiamo il metodo, usando il nome del servizio come primo parametro, poi i dati\r\n\r\nNotate, che in caso di errore ci sarebbe stata restituita un eccezione\r\n@XMLRPC::FaultException@.\r\n\r\n\r\nTutto piuttosto semplice. D\'altronde dover usare ogni volta @call()@ e\' una faticaccia. Sarebbe bello poter scrivere semplicemente @oggetto.metodo_soap()@.\r\nIn realta\' questo non solo e\' possibile, ma e\' anche molto semplice:\r\n >> proxy=client.proxy \'sample\'\r\n => #<XMLRPC::Client::Proxy:0x2ad8a10 @server=#<XMLRPC::Client:0x2ada978 @create=\r\n nil, @port=80, @http=#<Net::HTTP xmlrpc-c.sourceforge.net:80 open=false>, @proxy\r\n _host=nil, @http_last_response=nil, @parser=nil, @timeout=30, @path=\"/api/sample\r\n .php\", @auth=nil, @password=nil, @http_header_extra=nil, @use_ssl=false, @host=\"\r\n xmlrpc-c.sourceforge.net\", @user=nil, @proxy_port=nil, @cookie=nil>, @meth=:call\r\n , @args=[], @prefix=\"sample.\">\r\n >> proxy.sumAndDifference 5, 3\r\n => {\"difference\"=>2, \"sum\"=>8}\r\n\r\nIn pratica bisogno chiamara il metodo @proxy( )@ di un oggetto @Client@ passandogli come parametro il nome del servizio che desideriamo. \r\n\r\nIn altri linguaggi di scripting, ad esempio python, la libreria @XMLRPC@ riunisce @Client@ e @Proxy@ in un unico oggetto. \r\nNella libreria @XMLRPC@ di ruby, come anche in quella @SOAP@ esistono due oggetti differenti, perch&#233;?\r\n\r\nSemplice, per evitare sovrapposizioni tra i metodi di un normale oggetto (ad esempio @class()@ o @id@ e quelli del servizio rpc. \r\nSe avete la certezza di non aver problemi di questo tipo, potete tranquillamente usare un @Proxy@.\r\n\r\nPer semplificarci la vita, possiamo usare direttamente un @URI@ nel creare un oggetto @Client@ usando il metodo  @new2()@ \r\n\r\n  uri=\"http://www.oreillynet.com/meerkat/xml-rpc/server.php\"\r\n  proxy=XMLRPC::Client.new2(uri).proxy \'meerkat\'\r\n  data={\'search\'=> \'[Rr]uby\', \'num_items\'=> 5, \'descriptions\'=> 0}\r\n  proxy.getItems(data).each do |el|\r\n   puts \"\\nnotizia\"\r\n   puts el[\'title\']\r\n   puts el[\'description\']\r\n   puts el[\'link\']\r\n   puts \"\"\r\n  end\r\n\r\nChe dara\' un output del genere:\r\n \r\n notizia\r\n DistroWatch: Distributions, March 12, 2004 \r\n \r\n http://linuxtoday.com/news_story.php3?ltsn=2004-03-12-027-26-NW-RL  \r\n\r\n notizia\r\n Updated ap2-ruby to 1.1.1nb2 [taca 2004-03-12]\r\n \r\n ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/www/ap2-ruby/README.html\r\n\r\n notizia\r\n Updated ruby-base to 1.6.8.nb3  [taca 2004-03-12]\r\n \r\n ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/lang/ruby-base/README.html\r\n \r\n notizia\r\n Added ruby-fcgi [taca 2004-03-12]\r\n \r\n ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/www/ruby-fcgi/README.html  \r\n\r\n notizia\r\n Added ruby-amrita [taca 2004-03-12]\r\n\r\n ftp://ftp.netbsd.org/pub/NetBSD/packages/pkgsrc/textproc/ruby-amrita/README.html\r\n\r\n\r\n');
INSERT INTO `revisions` VALUES (88,42,16,'2005-11-25 13:01:15','h1.  Collaborazione_siforge\r \n\r\nsiforge.org ha pubblicato due articoli introduttivi a ruby, li potete trovare qui:\r\n *[[URL:http://www.siforge.org/articles/2003/05/26-ruby-intro-1.html]]\r\n *[[URL:http://www.siforge.org/articles/2003/06/28-ruby-intro-2.html]]\r\n \r\n');
INSERT INTO `revisions` VALUES (89,43,16,'2005-11-25 13:01:15','h1.  ContareLineeParoleCaratteri\r \n\r\nsemplice trucco per sapere quante linee sono contenuti in un file:\r\n\r\n File.new(\'miofile.txt\').readlines.length\r\n\r\n\r\nPotremmo, alternativamente, eliminare quel File.new(). Ci bastera\' scrivere:\r\n\r\n open(\'miofile.txt\').readlines.length\r\n\r\nContare le parole e\' un poco piu\' complesso. Quello che vogliamo fare e\' identificare \r\nogni punto in cui dei caratteri alfanumerici  siano separati da caratteri di spazio.\r\nBastera\'; leggere il file in memoria e poi spezzarlo ogni volta che incontriamo uno spazio,\r\no un tab, o un \"\\n\".\r\n\r\nFortunatamente il metodo split() e\' li per questo :)\r\n\r\n f=File.read(\'miofile.txt\') # legge tutto in memoria\r\n lista=f.split(/\\s+/)       # spezza il file traformandolo in un array\r\n array.length\r\n\r\ncome funziona String#split() ? semplice, gli passiamo una @Regexp@. In questo caso usiamo \"\\s\" che significa \"carattere di whitespace\" e aggiungiamo un \"+\" che significa \"uno o piu\'\".\r\nDunque quella riga significa: _spezza la riga in tanti pezzi, ognuno separato da uno o piu\' caratteri di spaziatura, come un tab uno spazio o un ritorno a capo_\r\n\r\n');
INSERT INTO `revisions` VALUES (90,44,16,'2005-11-25 13:01:15','h1.  ConTest\r \n\r\nNello spirito di [[Peter Seibel|URL:http://www.gigamonkeys.com/book/practical-building-a-unit-test-framework.html]] qui di seguito i risultati della disfida. Le regole erano:\r\n* non importa il linguaggio\r\n* vince chi ha il codice piu\' compatto\r\n* il codice deve essere capito almeno da 4 altri componenti del [[team|URL:http://www.extremeprogramming.it/cgi-lib/wiki.cgi?XpLayers]] ==> verranno brutalmente contati i \\n, splittando in automatico le righe quando diventano piu\' lunghe di 70 chars\r\n* nessun limite al numero di classi, metodi, ecc.\r\n* non e\' necessario che il codice sia OO\r\n* funzionalmente non e\' richiesto che faccia niente di piu\' dello step finale dell\'articolo, cioe\' il tutto deve essere comprensivo di qualche esempio (il codice di esempio non rientra nel conto)\r\n\r\nIl guanto della sfida e\' stato lanciato il 2-2-04, con verifica dei risultati l\'1-3-04\r\n\r\nVincitore: _VAA_!!!!\r\n\r\nh1. = VAA - Ruby\r \n # test.rb\r\n require \"rut.rb\"\r\n \r\n def testPlus\r\n   check(\r\n     \"1+2 == 4\",\r\n     \"1+2+3 == 6\",\r\n     \"-1 -3 == -4\"\r\n     )\r\n end\r\n \r\n def testStar\r\n   check(\r\n     \"2*2 == 4\",\r\n     \"3*2 == 6\"\r\n     )\r\n end\r\n \r\n def testArithmetic\r\n   combine(\r\n     testPlus,\r\n       testStar\r\n     )\r\n end\r\n \r\n def testMath\r\n   testArithmetic\r\n end\r\n \r\n puts testMath\r\n     \r\n # rut.rb\r\n def combine(*results) not results.flatten().include? false end\r\n def check (*all) combine all.collect{|t|c =caller-[caller.last]\r\n   c.collect!{|l|(l.include? \"rut.rb\")? nil : l.sub(/.*in/, \'\')} \r\n   puts (eval t)?\"pass ...#{c} #{t}\":\"FAIL ...#{c} #{t}\";eval t} end\r\n\r\nh1. = VAD - Smalltalk\r \n\r\n Trigo class >> check: what \r\n   what size = 0 ifTrue: [^true] ifFalse: [^(Trigo report: (what at: 1)) \r\n       & (Trigo check: (what copyFrom: 2 to: what size))]\r\n Trigo class >> filter\r\n   ^((thisContext sendersTo: nil) \r\n     select: [:each | \'*test*\' match: each printString]) reverse\r\n Trigo class >> report: aTest \r\n   | result eval |\r\n   eval := Compiler evaluate: aTest.\r\n   eval ifTrue:[result:=\': pass\'] ifFalse:[result:=\': FAIL\'].\r\n   Trigo filter do:[:each|Transcript show:each printString,\' \' ].\r\n   Transcript show: aTest, result,  \'\\\' withCRs.^eval\r\n\r\n\r\nh1. = QUA - Perl\r \n\r\n # conTest\r\n 01: sub makeTest {\r\n 02:     my $testname = shift;\r\n 03:     my @tests = map { ref $_ ? $_ : makeTestRunner($_) } @_;\r\n 04:     return sub { my $suitename=shift; our $level++; my $result=1;\r\n 05:         map { $result &= $_->($suitename.$testname.\' \') } @tests;\r\n 06:         --$level == 0 ? print $result ? \"T\":\"F\",\"\\n\" : $result; } }\r\n 07: sub makeTestRunner {\r\n 08:     my $code = shift; return sub { my $result = eval $code;\r\n 09:         print $result?\"pass\":\"fail\",\" ... ( \".shift().\") $code\\n\";\r\n 10:         $result ? 1:0 } } \"End of conTest :-)\";\r\n \r\n # examplePass\r\n use strict;\r\n use lib \".\";\r\n require \"conTest.pl\";\r\n \r\n my $testPlusMinus = makeTest(\"TestPlusMinus\", \"1+2==3\", \"1+1==2\", \"5+2==7\");\r\n $testPlusMinus->();\r\n print \"---------------------------------------------------\\n\";\r\n my $testMultiply = makeTest(\"TestMultiply\", \"1*2==2\", \"2*2==4\");\r\n $testMultiply->();\r\n print \"---------------------------------------------------\\n\";\r\n my $testArithmetic = makeTest(\"TestArithmetic\", $testPlusMinus, $testMultiply);\r\n $testArithmetic->();    \r\n print \"---------------------------------------------------\\n\";\r\n my $testMath = makeTest(\"TestMath\", $testArithmetic);\r\n $testMath->();    \r\n \r\n # exampleFail\r\n use strict;\r\n use lib \".\";\r\n require \"conTest.pl\";\r\n \r\n my $testPlusMinus = makeTest(\"TestPlusMinus\", \"1+2==3\", \"1+1==2\", \"5+2==7\");\r\n $testPlusMinus->();\r\n print \"---------------------------------------------------\\n\";\r\n my $testMultiply = makeTest(\"TestMultiply\", \"1*2==2\", \"2*2==5\");\r\n $testMultiply->();\r\n print \"---------------------------------------------------\\n\";\r\n my $testArithmetic = makeTest(\"TestArithmetic\", $testPlusMinus, $testMultiply);\r\n $testArithmetic->();    \r\n print \"---------------------------------------------------\\n\";\r\n my $testMath = makeTest(\"TestMath\", $testArithmetic);\r\n $testMath->();    \r\n\r\nh1. = Fuori concorso: BOP - Ruby\r \n\r\n def check(*tests)\r\n   stack = caller.map {|m| m[/\\w*(?=\')/]}.reverse.join(\" \").strip\r\n   tests.map {|t| puts \"#{(v=eval(t))?\'pass\':\'FAIL\'} ... (#{stack}) #{t}\"; v}.all?\r\n end\r\n \r\n def test_plus\r\n   check(\r\n     \"1 + 2 == 3\", \r\n     \"1 + 2 + 3 == 6\", \r\n     \"-1 + -3 == -4\")\r\n end\r\n def test_multiply\r\n   check(\r\n     \"2 * 2 == 4\",\r\n     \"3 * 5 == 15\")\r\n end\r\n \r\n def test_aritmetic\r\n   [test_plus, test_multiply].all?\r\n end\r\n \r\n def test_math\r\n   test_aritmetic\r\n end\r\n \r\n result = test_math\r\n puts \"result=#{result}\"\r\n\r\n');
INSERT INTO `revisions` VALUES (91,45,16,'2005-11-25 13:01:15','h1.  Convertire Fine Linea\r \n\r\nSe siete abituati ad usare notepad o un altro editor dalle ridotte capacita\' avrete notato che spesso alcuni file di testo non vengono visualizzati correttamente.\r\nTipicamente questo e\' dovuto all\'assenza di una convenzione su come i file di testo  dovrebbero indicare il ritorno a capo. \r\nSu Unix, tradizionalmente, si termina una linea con \"\\n\", su windows con \"\\r\\n\" e su macintosh con \"\\r\". \r\n\r\nOvviamente effettuare la conversione e\' banale:\r\n\r\nLeggiamo il file una linea per volta, spezandolo al separatore richiesto:\r\n >> f=open(\'nix.txt\').readlines(\"\\n\")\r\n >> f=open(\'mac.txt\').readlines(\"\\r\")\r\n >> f=open(\'win.txt\').readlines(\"\\r\\n\")\r\n\r\npoi, effettuiamo una trasformazione su tutti gli elementi del\'array, le linee: chiamiamo il metodo @chomp()@ che rimuove i caratteri \"\\r\" e \"n\", poi concateniamo il terminatore di linea appropriato:\r\n >>f.map! { |l| l.chomp+\"\\r\\n\" } # stampa come win\r\n >>f.map! { |l| l.chomp+\"\\n\" }   # stampa come nix\r\n >>f.map! { |l| l.chomp+\"\\r\" }   # stampa come mac\r\n\r\nPer finire il lavoro basta scrivere il tutto in un file, ma attenzione: dovete usare @print()@ e non @puts()@, perche\' quest\'ultimo appenderebbe alla vostra linea ancora un altro terminatore.\n');
INSERT INTO `revisions` VALUES (92,46,16,'2005-11-25 13:01:15','h1.  CookBook\r \n\r\nUn wiki deve essere un punto dove raccogliere informazioni. Per questo a partire da questa pagina potrete trovare un certo numero di \'ricette\' su come risolvere problemini comuni in ruby. \r\n\r\n  \r\nQualsiasi lettore e\' pregato di aggiungere le sue soluzioni alternative o di inserire nuovi problemi.\r\nCi sono molti cookbook in rete, per molti linguaggi. Il \"porting\" di soluzioni da quelli e\' incoraggiato ;)\r\n\r\nh1. = Fondamentali\r \n * [[Inizializzare una variabile se non lo e\' ancora|InizializzazioneCondizionale]]\r\n * [[Spezzare un percorso di un file|SpezzarePathFile]]\r\n * [[Cercare una stringa in un altra|CercareUnaStringaInUnAltra]]\r\n * [[Cercare stringhe all\'inizio o alla fine di una stringa|EspressioniRegolariBasi]]\r\n * [[Cercare stringhe con ripetizioni|EspressioniRegolariRipetizioni]]\r\n * [[Cercare stringhe con alternanza|EspressioniRegolariAlternanza]]\r\n * [[Trovare parole ripetute in una stringa|TrovareParoleRipetute]]\r\n * [[Usare la reflection|Reflection]]\r\n * [[Creare un oggetto iterabile con Enumerable|CreareEnumerable]]\r\n * [[Iterare su due oggetti in parallelo|IterareInParallelo]]\r\n * [[Salvare una Struttura su Disco|Marshall]]\r\n * [[Leggere metadati da un File|LeggereMetadatiDaFile]]\r\n * [[Duplicare un Oggetto|DuplicareUnOggetto]]\r\n * [[Eliminare elementi duplicati da una sequenza|EliminareDuplicati]]\r\nh1. = IPC \r \n * [[Far Comunicare Processi Correlati|UsarePipeEFork]]\r\n\r\n\r\nh1. = Gestire file di testo\r \n\r\n * [[Leggere un file un paragrafo alla volta|LeggereFileUnParagrafoAllavolta]]\r\n * [[Convertire fine linea da UNIX a Win a Mac|ConvertireFineLinea]]\r\n * [[Eliminare tabulazioni|EliminareTab]]\r\n * [[Contare linee o parole o caratteri|ContareLineeParoleCaratteri]]\r\n * [[Ordinare le linee in un file|OrdinareUnFile]]\r\n * [[Effettuare il word wrap di una stringa|WordWrap]]\r\n * [[Estrarre gli url contenuti in un testo|EstrarreURL]]\r\n * [[Escape di Caratteri Speciali|EscapeDiCaratteriSpeciali]]\r\n * [[Analisi statistica di parole in un testo|StatisticaParole]]\r\n\r\nh1. = Pattern e Idiomi \r \n * [[Iterare su sequenze|IterareSequenze]]\r\n * [[Multiplexer]]\r\n * [[Creare un Hash python-like|HashPythonLike]]\r\n * [[Creare un Hash JavaScript-like|HashJavaScriptLike]]\r\n * [[Costruire un Hash Infinito|HashInfinito]]\r\n * [[Iteratori Esterni|IteratoriEsterni]]\r\n * [[Iteratori Personalizzati|IteratoriPersonalizzati]]\r\n * [[Metodi che Sembrano Keyword|MetodiCheSembranoKeyword]]\r\n\r\nh1. = Programmazione di rete (socket, modulo Net etc)\r \n * [[Scrivere un client XML-RPC|ClientXMLRPC]]\r\n * [[Scrivere un client SOAP|ClientSOAP]]\r\n * [[Generare un client SOAP da un file WSDL|ClientSOAPDaWSDL]]\r\n\r\nh1. = Programmazione funzionale \r \n * [[Oggetti Proc e Method|OggettiProcEMethod]]\r\n * [[L\'iterazione funzionale: Map|FunzionaleMap]]\r\n * [[Filtrare con select() e reject()|FiltrareConSelectEReject]]\r\n * [[FormaLambda]]\r\n * [[Funzioni di ordine superiore|HOF]]\r\n * [[Currying]]\r\n\r\nh1. = Varie\r \n * [[ConTest]], ovvero un programming contest basato su _Building a Unit Test Framework_, di Peter Seibel\r\n * [[Rimuovere una Directory con tutto il suo contenuto|RimuovereDir]]\r\n * [[Lavorare con i numeri complessi|NumeriComplessi]]\r\n * [[Un Wiki da 5 righe|5RigheWiki]]\r\n * [[Generare XML con DOM|GenerareXMLConDom]]\r\n * [[Leggere file compressi|LeggereFileCompressi]]\r\n * [[Bowling in ruby partendo dagli articoli su smalltalk di Ron Jeffries|Bowling]]\n');
INSERT INTO `revisions` VALUES (93,47,16,'2005-11-25 13:01:16','h1.  Creare Enumerable\r \n\r\nEffettuare un\'iterazione su di un enumerabile (un @Array@ o una @String@ o un @Hash@)e\' semplice:\r\n\r\n enumerabile.each do |x|\r\n  fai cose con x\r\n end\r\n\r\nMa ovviamente un @Enumerable@ ci offre anche altri metodi molto comodi.\r\nAd esempio, @map()@ per effettuare una trasformazione du tutti gli elementi dell\'oggetto, @sort()@ per ordinarli, @select()@ per selezionarne alcuni e cos&#236; via.\r\n\r\nMa come possiamo fare noi per creare un oggetto con questi metodi?\r\n\r\nSe conoscete Java starete pensando \"_oh, no, devo implementare l\'interfaccia!_\", ma in ruby, grazie ai [[Mix-in]] potete evitarlo. Tutto quello di cui avete bisohgno e\' un metodo @each()@. \r\n\r\nVediamo un esempio. Inizialmente creiamo una classe @Tripla@:\r\n\r\n >> class Tripla\r\n >>  def initialize(a,b,c)\r\n >>   @a,@b,@c=a,b,c\r\n >>  end\r\n >>  def each\r\n >>   yield @a\r\n >>   yield @b\r\n >>   yield @c\r\n >>  end\r\n >> end\r\n => nil\r\n\r\nfin qui tutto semplice. Ora vediamo se funziona:\r\n\r\n >> t=Tripla.new 10, 20, 30\r\n => #<Tripla:0x27bd060 @b=20, @a=10, @c=30>\r\n >> t.each { |x| puts x }\r\n 10\r\n 20\r\n 30\r\n => nil\r\n\r\nperfetto! \r\nMa ancora, questa classe non e\' completa. Per renderla simile ad @Array@ o @Hash@ dobbiamo enderla un @Enumerable@). Niente di complesso: \r\n >> class Tripla\r\n >>  include Enumerable\r\n >> end\r\n => Tripla\r\n\r\nEd ora:\r\n >> t=Tripla.new 17,42,11\r\n => #<Tripla:0x2753c30 @b=42, @a=17, @c=11>\r\n >> puts t.sort  # ordiniamoli\r\n 11\r\n 17\r\n 42\r\n => nil\r\n >> puts t.map {|x| x*2} # raddoppiamo i valori\r\n 34\r\n 84\r\n 22\r\n => nil\r\n >> puts t.select {|x| x%2==1} # selezioniamo i dispari\r\n 17\r\n 11\r\n => nil \r\n\r\n\r\nFacile no? ;)\n');
INSERT INTO `revisions` VALUES (94,48,16,'2005-11-25 13:01:16','h1.  Currying\r \n\r\nIl currying e\' un meccanismo molto curioso pensato da un matematico d nome Haskell Curry.\r\nIn pratica si tratta di un\'applicazione parziale di una funzione che genera un\'altra funzione. O del pensare ad ogni funzione come una funzione che accetta un solo argomento, e ne restituisce generalmente un\'altra.\r\n\r\nVi sembra difficile? non lo e\', tranquilli :) \r\nAd esempio, se io ho una funzione @somma(arg1,arg2@ posso effettuare il @currying@ tra la funzione ed _un solo_ valore , ed ottenere una funzione che accetti un solo valore ad un altro. \r\n\r\nAd esempio, in ocaml, un linguaggio funzionale che ha il currying automatico, scriverei:\r\n\r\n* dichiarazione della funzione:\r\n let somma arg1 arg2 = arg1+arg2 ;;  \r\n\r\n* creiamo la funzione incompleta, effettuando il currying automatico:\r\n let somma_due  = somma 2 ;;\r\n\r\n* usiamo la funzione:\r\n somma_due 10 ;;\r\n - : int = 12\r\n\r\nL\'ultima riga sarebbe il risultato, @12@.\r\n\r\nPochi linguaggi hanno un sistema di currying automatico, ma in linguaggi come ruby che danno la possibilita\' di manipolare funzioni e crearle \"al volo\" e\' semplice realizzare una funzione @curry()@ che prenda in input una funzione e dei valori:\r\n\r\n def curry(funz, *alcuni_arg)\r\n     proc { |*altri_arg| funz[*(alcuni_arg + altri_arg)] }\r\n end\r\n\r\n\r\ncosa facciamo in quel casino?\r\n\r\nandiamo per gradi:\r\n (1) la funzione prende in input un oggetto funzione (@Proc@ o @Method@) e degli argomenti di default.\r\n (2) all\'interno della funzione viene generata una [[funzione anonima|FormaLambda]]\r\n (3) la funzione anonima richiama tramite l\'operatore \"@[]@\" la funzione ricevuta in input\r\n (4) gli argomenti passati alla funzione in input sono quelli passato alla funzione @curry()@ piu\' quelli passati effettivamente all\'oggetto @Proc@. Questi argomenti sono @Array@ che vengono prima sommati tra loro (cioe\' concatenati) e poi _espansi_ grazie alla sintassi @*(Array)@\r\n     \r\nVediamo la nostra funzione all\'opera:\r\n >>  def curry(funz, *alcuni_arg)\r\n >>      proc { |*altri_arg| funz[*(alcuni_arg + altri_arg)] }\r\n >>  end\r\n => nil\r\n >> def somma(arg1,arg2) arg1+arg2 end\r\n => nil\r\n >> s=method :somma\r\n => #<Method: Object#somma>\r\n >> somma_2 = curry(s, 2)\r\n => #<Proc:0x027be8e0@(irb):53>\r\n >> somma_2[10]\r\n => 12\r\n\r\nVolendo avremmo potuto far si che @curry()@ prendesse in input solamente il simbolo di una funzione, ma questa e\' una soluzione lasciata al lettore :) \r\n\r\nGuardate quest\'ultimo esempio: @curry()@ funziona per tutti gli argomenti che vogliamo\r\n >> def somma_5(a1,a2,a3,a4,a5) a1+a2+a3+a4+a5 end\r\n => nil\r\n >> s=method :somma_5\r\n => #<Method: Object#somma_5>\r\n >> somma_4_e_1 =curry s, 1\r\n => #<Proc:0x027be8e0@(irb):53>\r\n >> somma_4_e_1[2,3,4,5]\r\n => 15\r\n >> somma_1_e_4 =curry s, 1, 2,3,4\r\n => #<Proc:0x027be8e0@(irb):53>\r\n >> somma_1_e_4[5]\r\n => 15\n');
INSERT INTO `revisions` VALUES (95,49,16,'2005-11-25 13:01:16','h1.  Documentazione\r \n\r\nh1. == Manuali ruby\r \nI link ai testi piu\' corposi sono in queste sottopagine:\r\n\r\n* [[Guide in italiano|GuideInIta]]\r\n\r\n* [[Guide in inglese|GuideInEng]]\r\n\r\n\r\n\r\nh1. == Guide per Ruby/Tk\r \n *[[link dedicati allo sviluppo con Tk|Gui con Tk]]\r\n\r\nh1. == Introduzione a ruby\r \nDue articoli introduttivi su ruby:\r\n * [[Parte 1|URL:http://www.siforge.org/articles/2003/05/26-ruby-intro-1.html]]\r\n * [[Parte 2|URL:http://www.siforge.org/articles/2003/06/28-ruby-intro-2.html]]\r\n\r\nh1. == Slide di Matley\r \nAlcune slides di presentazione a Ruby scritte per il Linux Day 2003 a Pavia:\r\n* [[Matley\'s slides|URL:http://ada2.unipv.it/~matley/rubytalk]]\r\n\r\nh1. == Slide di RiffRaff\r \nSlide per il Linux Day 2004 a Roma\r\n* [[RiffRaff\'s slides|URL:http://ada2.unipv.it/~riffraff/linuxday-2004.tgz]]\r\nh1. == Scuse Frequenti\r \nPer quelli che si lamentano di feature di ruby\r\nsenza aver mai scritto due righe di codice :)\r\n* [[ScuseFrequenti]]\r\n\r\n\r\nh1. == Ruby per chi ama Python\r \n* [[RubyForPythonista]]\r\n\r\nh1. == Ruby per chi usa Java\r \n* [[RubyForJavanese]]\r\n\r\nh1. == Cosa sono le Singleton Class\r \n* [[Introduzione alle classi singleton (semplice)|SingletonClass]]\r\n\r\nh1. == OnLispOnRuby \r \n* [[un folle tentativo di porting da OnLisp di paul graham a ruby|OnLispOnRuby]]\n');
INSERT INTO `revisions` VALUES (96,50,16,'2005-11-25 13:01:16','h1.  DuplicareUnOggetto\r \n\r\nCreare una copia di un oggetto non e\' la stessa cosa che creare una variabile che usi lo stesso oggetto. \r\nCon l\'operattore di assegnazione (il \"@=@\") diciamo semplicemente a ruby \"_ questa variabile rappresenta quell\'oggetto_\":\r\n\r\n >> s1=\'ciao\'\r\n => \"ciao\"\r\n >> s2=s1\r\n => \"ciao\"\r\n >> s1.object_id==s2.object_id\r\n => true\r\n\r\nDovrebbe essere ovvio che @object_id()@ ci restituisce un valore che identifica univocamente un oggetto :)\r\n\r\nOvviamente, in alcuni casi vorremmo avere un oggetto che si uguale ad un altro, ma non lo stesso, magari perche\' vogliamo cambiare uno dei due indipendentemente dall\'altro.\r\n\r\nIn questo caso dobbiamo usare @dup()@ :\r\n >> s1=\'ciao\'\r\n => \"ciao\"\r\n >> s2=s1.dup\r\n => \"ciao\"\r\n >> p s1.object_id, s2.object_id\r\n 20905692\r\n 20897916\r\n => nil\r\n\r\ncome vedete l\'@object_id@ e\' differente tra i due.\r\nSe volete potete anche usare @clone()@ , che e\' un alias di @dup()@:\r\n >> s3=s2.clone\r\n => \"ciao\"\r\n >> p s1.object_id,s2.object_id,s3.object_id\r\n 20905692\r\n 20897916\r\n 20877096\r\n => nil\r\n\r\nOvviamente sono diversi oggetti , ma ognuno e\' uguale agli altri:\r\n\r\n >> s1== s2 and s2== s3\r\n => true\r\n\r\nOvviamente dovete definire voi un metodo @dup()@ in maniera coerente. Ricordate che in genere la duplicazione implica la duplicazione degli ettributi, e non il semplice riferimento agli stessi. \r\n');
INSERT INTO `revisions` VALUES (97,51,16,'2005-11-25 13:01:16','h1.  EliminareTab\r \n\r\nEliminare i tab e sostituirli con degli spazi risulta molto utile quando si ha a che \r\nfare con testi scritti da persone diverse, o per venire incontro al proprio gusto.\r\n\r\nUn soluzione semplice: dividiamo la stringa in sottostringhe, \r\ne le mettiamo temporaneamente in un array. Poi calcoliamo quanti spazi dobbiamo \r\ninserire, ed alla fine riuniamo il tutto. Agiungiamo ancora uno spazio, visto che \r\nla split() ha rimosso un carattere :\r\n\r\n\r\n def expand(stringa, tablen=8)\r\n    res = []\r\n    for substr in stringa.split(\"\\t\")\r\n        res.push substr\r\n        res.push \' \'*(tablen - stringa.size %tablen)\r\n    end	\r\n    return res.join(\' \')\r\n end\r\n\r\n\r\nUna soluzione migliore e piu\' rubyish puo\' essere:\r\n def expand(str, tablen=8)\r\n  str.split(\"\\t\").inject { |a,b| a +  \' \' * ( tablen - a.size % tablen )  + b }\r\n end\r\n\r\nIn pratica invece di usare un for esplicitamente usiamo inject() che applica il blocco \r\nogni volta ad un elemento dell\'array ottenuto da split() ed al \r\nrisultato della computazione precedente. bello vero? :)\r\n');
INSERT INTO `revisions` VALUES (98,52,16,'2005-11-25 13:01:16','h1.  EstrarreURL\r \n\r\nEstrarre url da un testo e\' una cosa che capita spesso di fare.\r\nPensate ad esempio, se voleste scrivere un programa come wget o teleport pro,\r\ndovreste scaricare una pagina web, poi cercare i link al suo interno, e poi\r\nscaricare quelle nuove pagine e ricominciare.\r\nGrazie al modulo @URI@ questo diventa facilissimo:\r\n\r\n    require \"uri\"\r\n    \r\n    URI.extract(\"bla bla baa http://foo.bar.com/foobar mailto:pippo@mai.com\")\r\n    #=> [\"http://foo.bar.com/foobar\", \"mailto:foo@bar.com\"]\r\n\r\nCome vedete il modulo @URI@  cattura, appunto, un uri, sta poi a voi verificare che sia http o ftp o altro. Questo modulo permette anche di analizzare un singolo uri, e trarne informazioni utili, ma questo e\' fuori dall\'interesse di questa ricetta :)\n');
INSERT INTO `revisions` VALUES (99,53,16,'2005-11-25 13:01:16','h1.  EliminareDuplicati\r \n\r\n\r\nSebbene sia una cosa _decisamente comune_, moltissimi linguaggi non hanno un meccanismo semplice per farlo. \r\nIn ruby per fortuna esiste @Array#uniq@ il cui uso e\' banalissimo:\r\n\r\n irb(main):001:0> [1,2,1,34,12].uniq\r\n => [1, 2, 34, 12]\r\n\r\n\r\nAh che bello avere tipi builtin cosi\' ricchi :) \n');
INSERT INTO `revisions` VALUES (100,54,16,'2005-11-25 13:01:16','h1.  EscapeDiCaratteriSpeciali\r \n\r\n\r\nCapita di aver bisogno di effettuare l\'_escape_ di alcuni caratteri in delle stringhe. (apici singoli o doppi, slasho backslash, etc..). Ad esempio, se l\'output del vostro programma deve essere passato ad una shell, dovrete aggiungere un \"@\\@\" davanti a quei simboli. Per la soluzione e\' ovvio che bisogna usare @String#gsub()@, e per fare le cose in modo chiaro useremo la sintassi di @gsub@ che accetta un blocco:\r\n\r\n  stringa.gsub(/[caratteri]/) { |match| \"\\\\\"+match }\r\n\r\nin pratica tutto questo significa: _sostituisci ogni  carattere contenuto tra le parentesi quadre con il risultato del blocco_.\r\n Il blocco prende in input ogni carattere contenuto tra le parentesi quadre, \r\ne gli aggiunge una \"@\\@\" davanti. Dobbiamo scriverne due per far capire a ruby che ne vogliamo una, come in tutti i limguaggi, anche qui abbiamo bisogno di escape :)\r\n\r\nSe invece volessimo raddoppiare i caratteri scriveremmo:\r\n\r\n  stringa.gsub(/[carat]/) { |match| match*2 }\r\n\r\n\r\n(questo e\' utile, ad esempio, se usate la stringa all\'interno di una chiamata a @sprint@ o altre funzioni di formattazione di stringhe)\r\n\r\nNotate anche che se volete rimpiazzare un singolo carattere vi basterebbe scrivere:\r\n\r\n  stringa.gsub(/c/) { |match| match*2 }\r\n\r\nUn tipico esempio di come fare l\'escape di apici per usare una stringa in una shell:\r\n\r\n  str.gsub(/[\'\"]/) { |match| match*2 }\r\n\r\n');
INSERT INTO `revisions` VALUES (101,55,16,'2005-11-25 13:01:16','h1.  Regexp con Alternanza\r \n\r\nOk, questa parola probabilmente non avra\' senso per voi. Nemmeno per me ne ha, ma e\' l\'unico modo in cui riesco a tradurre \"_alternation_\".\r\n\r\nCosa sto cercando di dirvi? Niente di complesso, semplicemente che potete scrivere delle @Regexp@ che accettino varie alternative:\r\n >> rgx= /ciao|bau|miao/\r\n => /ciao|bau|miao/\r\n >> \'ciao\'=~ rgx\r\n => 0\r\n >> \'bau\'=~ rgx\r\n => 0\r\n >> \'bao\'=~ rgx\r\n => nil\r\n >> \'miao\'=~ rgx\r\n => 0\r\n >> \'mao\'=~ rgx\r\n => nil\r\nil simbolo di _pipe_ (\"@|@\") rappresenta in molti linguaggi il connettore logico \"@or@\". Dunque quella @Regexp@ significa \"_ ciao o bau o  miao_\".\r\n\r\nNotate che potete anche scrivere cose come questa:\r\n >> rgx= /(c|m)iao/\r\n => /(c|m)iao/\r\n >> \'miao\'=~ rgx\r\n => 0\r\n >> \'ciao\'=~ rgx\r\n => 0\r\n >> \'biao\'=~ rgx\r\n => nil\r\n\r\nche tradotta in linguaggio umano significa \"_c oppure m, e dopo iao_.\r\nLe parentesi rappresentano anche il cosidetto _group operator_, cioe\' dicono a ruby di conservare il gruppo di caratteri che sorrispondono all\'espressione tra parentesi, perche\' potremmo decidere di usarli.\r\n\r\nAd esempio, in questo caso ruby manterrebbe la lettera \"@c@\" o la \"@m@\".\r\n\r\nMa dove vengono conservati questi dati sul match?\r\n\r\nbeh, se usiamo le espressioni regolari con uno stile ad oggetti:\r\n >> m=rgx.match \'ciao\'\r\n => #<MatchData:0x27bc2e8>\r\n >> m[0]\r\n => \"ciao\"\r\n >> m[1]\r\n => \"c\"\r\n\r\ncome vedete, al posto zero troviamo l\'intera stringa matchata, mentre all\'uno semplicemente la sottosringa matchata dal primo gruppo, cioe\' quella contenuta nelle prime due parantesi. \r\n\r\nVediamo un altro esempio:\r\n >> rgx= /(c)(i)(ao)/\r\n => /(c)(i)(ao)/\r\n >> m=rgx.match \'ciao\'\r\n => #<MatchData:0x2758538>\r\n >> m[1]\r\n => \"c\"\r\n >> m[2]\r\n => \"i\"\r\n >> m[3]\r\n => \"ao\"\r\n\r\nQuesto meccanismo e\' anche molto simile a quello di python. Ruby dal canto suo, permette di usare le regexp anche in uno stile piu\'; procedurale, che poi e\' ispirato a perl, sed, awk e tutti i linguaggi pii\' vecchi in cui sono state introdotte le espressioni regolari.\r\n\r\nIn questo caso, i match vengono salvati in delle variabili speciali, che non non vediamo affatto, ma che sono gestite da ruby per noi:\r\n >>  \'ciao\' =~ rgx\r\n => 0\r\n >> $1\r\n => \"c\"\r\n >> $2\r\n => \"i\"\r\n >> $3\r\n => \"ao\"\r\n\r\nIn pratica dobbiamo usare una variabile globale di nome <dollaro><numero> dove numero indica il gruppo. Anche se questa sintassi vi sembra strana, ricordate che si tratta di quella adottata generalmente nell\'ambito dell\'uso delle regexp, anche se con qualche variante (ad esempio, in vbscript esiste @RegExp.$1@ @RegExp.$2@ e cosi\' via)\r\n\r\n\r\n\r\n');
INSERT INTO `revisions` VALUES (102,56,16,'2005-11-25 13:01:16','h1.  EspressioniRegolariBasi\r \n\r\nAbbiamo gia visto come si creano dele semplici espressioni regolari:\r\n >> rgx= /esp/\r\n => /esp/ \r\n >> rgx= Regexp.new(\"esp\")\r\n => /esp/\r\n\r\nora vediamo cose piu\' interessanti.\r\nSappiamo che una stringa da cercare viene espressa cosi\':\r\n /stringa/\r\n\r\nad esempio @/via/@ effettuera\' il _match_, cioe\' trovera una corrispondenza, sia in \"@ferrovia@\" che in \"@funivia@\", che in \"@viadotto@\".\r\nSe volessimo solo le parole che _finiscono_ con \"@via@\" dovremmo usare un carattere speciale (in genere si dicono _metacaratteri_), il dollaro (\"@$@\").\r\n\r\nQuesto carattere indica _la fine di una riga_:\r\n\r\n >> rgx= /via$/\r\n => /via$/\r\n >> \'ferrovia\' =~ rgx\r\n => 5\r\n >> \'viadotto\' =~ rgx\r\n => nil\r\n\r\nIl gemello di \"@$@\" e\' \"@^@\", che significa _inizio della riga_:\r\n\r\n >> rgx= /^via/\r\n => /^via/\r\n >> \'ferrovia\' =~ rgx\r\n => nil\r\n >> \'viadotto\' =~ rgx\r\n => 0\r\n\r\nOvviamente una espresione regolare puo\' usare entrambi i meccanismi insieme:\r\n >> rgx= /^via$/\r\n => /^via$/\r\n >> \'viadotto\' =~ rgx\r\n => nil\r\n >> \'ferrovia\' =~ rgx\r\n => nil\r\n >> \'via\' =~ rgx\r\n => 0\r\n\r\nNiente di assurdo, finora. Ovviamente le espressioni regolari sono molto piu\' potenti di cosi\', ma per questa pagina di wiki puo\' bastare :)  \r\n\r\n');
INSERT INTO `revisions` VALUES (103,57,16,'2005-11-25 13:01:16','h1.  Regexp con ripetizioni\r \n\r\nSe avete usato almeno una volta una shell a riga di comando (sh, bash, command,com..) o anche un normale sistema di ricerca sul file system avrete usato quello che viene detto \"_globbing_\", cioe\' quel meccanismo che vi permette di scrivere \"@*.txt@\" per intendere \"_tutti i file che hanno un qualunque nome ed un\'estensione txt_\".\r\n\r\nNelle espressioni regolari, il simbolo di asterisco (\"@*@\") significa \"_zero o piu\'_ \", facendo riferimento al carattere subito prima:\r\n\r\n >> rgx= /sa*s/\r\n => /sa*s/\r\n >> \'sas\' =~ rgx\r\n => 0\r\n >> \'saas\' =~ rgx\r\n => 0\r\n >> \'saaas\' =~ rgx\r\n => 0\r\n >> \'ss\' =~ rgx\r\n => 0\r\n\r\nnotate che abbiamo un match anche quando la \"a\" non appare. L\'asterisco significa _zero_ o piu\'.\r\nQuesto meccanismo diventa piu\' interessante usando un carattere speciale, o metacarattere, che rappresenta un carattere qualsiasi. Questo metecarattere e\' il punto (\"@.@\").\r\nIl punto sara\' felice di riconoscersi in qualunque altro carattere, ammesso che un carattere ci sia:\r\n >> rgx= /s./\r\n => /s./\r\n >> \'ss\' =~ rgx\r\n => 0\r\n >> \'s \' =~ rgx\r\n => 0\r\n >> \'s#\' =~ rgx\r\n => 0 \r\n >> \'s\' =~ rgx\r\n => nil\r\n\r\nImmaginate cosa succede usando un punto ed un asterisco:\r\n >> rgx= /s.*o/\r\n => /s.*o/\r\n >> \"sesso\" =~ rgx\r\n => 0\r\n >> \"sasso\" =~ rgx\r\n => 0\r\n >> \"sono io\" =~ rgx\r\n => 0\r\n >> \"s o\" =~ rgx\r\n => 0\r\n >> \"s \" =~ rgx\r\n => nil\r\n\r\nfacilissimo.\r\nUn altro metecarattere che esprime un certo numero di rpetizione e\' il punto interrogativo \r\n(\"@?@\"), che significa \"o una o zero ripetizioni\":\r\n >> rgx= /s.?o/ # una s, una ripetizone o zero di un carattere qualsiasi e una o\r\n => /s.?o/\r\n >> \'sio\'=~ rgx\r\n => 0\r\n >> \'so\'=~ rgx\r\n => 0\r\n >> \'saao\'=~ rgx\r\n => nil\r\n\r\nInfine, la ripetizione che indica \"uno o piu\' \" , in pratica invece di scrivere.\r\n <carattere>?<carattere>*\r\n\r\nscriveremo\r\n <carattere>+\r\n\r\nEsempio:\r\n >> rgx= /s.+o/ # una s, uno o piu\' caratteri qualsiasi e una o\r\n => /s.+o/\r\n >> \'so\'=~ rgx\r\n => nil\r\n >> \'sao\'=~ rgx\r\n => 0\r\n >> \'sono io\'=~ rgx\r\n => 0\r\n >> \'sono io\'=~ rgx\r\n\r\n\r\nUn altro modo per usare le ripetizioni e\' dichiarare esplicitamente nella @Regexp@ il numero.\r\nIl meccanismo e\' semplice, basta usare una coppia di parentesi graffe, ed all\'interno scrivere il numero minimo e massimo di match:\r\n >> rgx= /a{1,2}/\r\n => /a{1,2}/\r\n >> \'ciao\' =~ rgx\r\n => 2\r\n >> \'ciaao\' =~ rgx\r\n => 2\r\n >> \'cio\' =~ rgx\r\n => nil\r\n\r\nInoltre, invece di scrivere @{n,n}@ potete scrivere solo @{n@. Ad esempio:\r\n >> rgx= /a{2}/\r\n => /a{2}/\r\n >> \'ciaao\' =~ rgx\r\n => 2\r\n >> \'ciao\' =~ rgx\r\n => nil\r\n\r\n\r\n');
INSERT INTO `revisions` VALUES (105,59,16,'2005-11-25 13:01:16','h1.  Help \r \n\r\n\r\nh1. = Wiki? che sarebbe?\r \n\r\nUn wiki e\' un sistema di pubblicazione su web collaborativo.\r\n\r\nChiunque puo\' aggiungere pagine se lo desidera, o modificare\r\npagine esistenti.\r\n\r\nAd esempio se voleste scrivere una sezione sull\'uso di\r\nRuby con Mysql Potete farlo online e vedere pubblicato\r\nil tutto immediatamente.\r\n\r\nh1. = Come modificare le pagine?\r \n\r\nBasta raggiungere la pagina e cliccare su _Edit_  in alto a destra.\r\n\r\nh1. = Che strano formato!\r \n\r\nIl formato delle pagine e\' il formato RD.\r\nSostanzialmente vi basti sapere questo:\r\n * questo e\' un elenco puntato, basta indentare\r\n   il tutto e mettere degli asterischi per ogni riga/elemento.\r\n * la pagina inizia con \"= nomepagina\"\r\n * i link a altre pagine del wiki si scrivono cosi\':\r\n    [[Prova]]\r\n * il corsivo si fa cosi\'\r\n    _bla bla bla  _\r\n * i sottopragrafi si ottengono cosi\'\r\n    \"== SottoParagrafo\" o \"=== Sotto Sotto Paragrafo\"\r\n * effetto macchina da scrivere :\r\n    @o schermo@\r\n\r\nper evitare che il codice venga interpretato, indentate di un ulteriore spazio(es. per inserire codice Ruby).\r\n\r\nDate un\'occhiata al sorgente di questa pagina per capire :)\r\n\r\nh1. = Emh.. si, ma come ne creo una nuova?\r \n\r\nbasta aprire una pagina esistente, e aggiungere un link.\r\nUna volta fatto questo si puo\' salvare con il bottone _Save_ qui sotto,\r\ne cliccare sul link appena creato per raggiungere la pagina.\r\n\r\nOra potete scrivere quello che volete :)\r\n\r\n\r\n\r\n[[Prova]] e\' una pagina di.. emh.. prova, per fare tutti i casini che volete :)\r\n\r\nh1. = Cosa significano quelle scritte in fondo alle pagine?\r \n\r\nindicano rispettivamente:\r\n * l\'url effettivo della pagina\r\n * la data di ultima modifica\r\n * le pagine che hanno un link verso di essa.\r\n   Per ognuno di tali link e\' indicato il tempo passato dall\'ultima modifica.\r\n\r\n\r\nh1. == Per maggiori informazioni sul formato RD consultare [[URL:http://www2.pos.to/~tosh/ruby/rdtool/en/doc/rd-draft.html]] \n');
INSERT INTO `revisions` VALUES (107,61,16,'2005-11-25 13:01:16','h1.  FiltrareConSelectEReject\r \n\r\n\r\n\r\nSupponiamo di voler raccogliere in un @Array@ tutte le linee del nostro file d\'esempio che riteniamo lunghe, ciow\' quelle con piu\' di 7 caratteri (si, ok, non sono proprio molto lunghe, ma usate la fantasia :-). Un approccio comune sarebbe:\r\n\r\n def linea_lunga?(linea)\r\n   linea.length > 7\r\n end\r\n risultato=[]\r\n File.new(\'esempio.txt\').each do |l|\r\n   risultato.push(l) if linea_lunga?(l)\r\n end\r\n\r\n\r\n \r\nAlternativamente, possiamo usare il metodo @select()@, in questo modo:\r\n\r\n puts File.new(\'esempio.txt\').select { |x| linea_lunga?(x) }\r\n\r\n\r\nla funzione si preoccupa di costruire al posto nostro un array con i valori che risultano validi per la condizione nel blocco.\r\n\r\n\r\nE se avessimo avuto bisogno di un ulteriore condizione? Niente di complesso\r\n\r\n def con_numeri(linea)\r\n  /[0-9]/.match(linea)\r\n end\r\n\r\n puts File.new(\'esempio.txt\').select { |x| linea_lunga?(x) and con_numeri(x) }\r\n\r\n\r\nAncora, sapendo che possiamo usare degli oggetti @Proc@\r\n        \r\n\r\n lunga=proc do |lin|\r\n  lin.length > 7\r\n end\r\n\r\n num=proc do |lin|\r\n  /[0-9]/.match(lin)\r\n end\r\n\r\n puts File.new(\'esempio.txt\').select(&lunga).select(&num)\r\n\r\n\r\nFacile no?. \r\n\r\nIl compagno ideale di @select()@ e\' @reject()@. Questa funzione restituisce un @Array@ contenente gli elementi per i quali il blocco e\' falso. Cioe\', _rigetta_ tutti quelli che rendono vera la condizione:\r\n\r\n >> [1,2,3,4,5,6,7,8,9,1000].reject {|i| i%2==1 } # i dispari\r\n => [2, 4, 6, 8, 1000]\r\n\r\nNel piu\' classico stile funzionale, queste funzioni non hanno _side effect_ cioe\' non modificano nulla nella struttura originale. Notate poi, che si tratta di metodi contenuti nel modulo @Enumerable@ e che quindi sono disponibili in qualsiasi struttura definisca @each()@, sia esso un @Array@, un @Hash@, un @File@ o un @Socket@\n');
INSERT INTO `revisions` VALUES (108,62,16,'2005-11-25 13:01:16','h1.  FormaLambda\r \n\r\ncos\'e una funzione lambda?\r\nSi tratta di una funzione anonima sostanzialmente.\r\nQuello che fate quando usate @each()@:\r\n array.each { |argomenti| codice }\r\n\r\nin realta\' e\' equivalente a \r\n\r\n def f(argomenti)\r\n\r\n  codice\r\n end\r\n for i in array\r\n  f(i)\r\n end\r\n\r\nnon e\' un caso che in ruby si possa creare una funzione anonima, cioe\' un oggetto @Proc@ scrivendo:\r\n oggetto= lambda {|args| codice}\r\n\r\nLe funzioni anonime sono talmente utili che sono state introdotte in molti dei linguaggi moderni: C#, python, ruby sono degli esempi.\r\n\r\nC\'e una differenza sottile tra le lambda di C#/python e quelle di ruby/lisp (la definizione di _vere chiusure lessicali_.e\' ambigua, in ogni caso).\r\n\r\nIn realta\' la differenza e\' _molto_ sottile. Definiamo lo _scope lessicale_. In pratica significa che una funzione fa riferimento a delle variabili basandosi su quello che viene definito intorno a se direttamente nel testo, e non al momento dell\'esecuzione del codice. \r\n\r\nSembra complicato ma non lo e\', guardate:\r\n >> def esponenziale(num)\r\n >>  proc { num=num*num }\r\n >> end\r\n => nil\r\n >> b=esponenziale(2)\r\n => #<Proc:0x027d61d8@(irb):2>\r\n >> a=esponenziale(3)\r\n => #<Proc:0x027d61d8@(irb):2>\r\n >> a.call\r\n => 9\r\n >> b.call\r\n => 4\r\n >> a.call\r\n => 81\r\n >> a.call\r\n => 6561\r\n >> b.call\r\n => 16 \r\n\r\ncosa succede? succede che l\'oggetto @Proc@ si _chiude_ sopra alle variabili che si trovano nel suo pezzettino di codice. Non importa se poi noi usiamo altri valori (ad esempio, richiamando @esponenziale()@ con un altro parametro.\r\n\r\nPerche\' questo sistema e\' diversa da quello di python e C#?\r\n((*pregasi verificare, nn sono esperto di python,\r\nfaccio riferimento a [[Paul Graham|URL:http://store.yahoo.com/paulgraham/accgen.html]]*))\r\n\r\n >>> def esponenziale(n):\r\n ...  lambda a: n=n*n\r\n ...\r\n   File \"<stdin>\", line 2\r\n SyntaxError: can\'t assign to lambda\r\n\r\nPython ha delle _chiusure lessicali_ nelle quali si ha riferimento all\'oggetto, ma non alla variabile stessa. Il comportamento va emulato, chiudendo la variabile in un altro oggetto\r\n  def esponenziale(n):\r\n   ary=[n]\r\n   def f():\r\n    ary.append(ary.pop()**2)\r\n    return ary[0]\r\n   return f\r\n\r\nMa stiamo divagando :)\r\n\r\nUn\'altra cosa affascinante che possiamo fare con le chiusure lessicali e\' la condivisione di variabili tra diverse procedure:\r\n\r\n >> def add_sub(default)\r\n >>   return proc {default+=1},proc {default-=1}\r\n >> end\r\n => nil\r\n >> add,sub=add_sub(10)\r\n => [#<Proc:0x0275a968@(irb):25>, #<Proc:0x0275a878@(irb):25>]\r\n >> add\r\n => #<Proc:0x0275a968@(irb):25>\r\n >> add.call \r\n => 11\r\n >> sub.call\r\n => 10\r\n >> sub.call\r\n => 9\r\n >> add.call\r\n => 10\r\n >> add.call\r\n => 11\r\n >> add.call\r\n => 12\r\n >> sub.call\r\n => 11\r\n\r\n\r\nOvviamente, vi starete chiedendo a cosa cavolo vi serve qesta cosa. Beh, capirete l\'utilita\', forse, pensando che tra le altre cose, un blocco, cioe\' un oggetto proc, cioe\' una chiusura lessicale, e\' quello che definisce il comportamento di un @Thread@\r\n Thread.new { codice}\n');
INSERT INTO `revisions` VALUES (109,63,16,'2005-11-25 13:01:16','h1.  FunzionaleMap\r \n\r\nA cosa serve @map()@\r\nEssa permette di applicare una funzione su ogni elemento di una collezione, restituendo un Array con i risultati. In pratica, invece di             \r\n ary=Array.new\r\n for i in oggEnumerable \r\n  ary.push(funzione(i))\r\n end\r\n puts ary\r\n\r\nbasta fare:\r\nputs oggEnumerable.map {|i| funzione(i)}\r\n\r\no se abbiamo a disposizione [[oggetti Proc o Method|OggettiProcEMethod]]:\r\n puts oggEnumerable.map &funzione\r\n\r\nAd esempio, supponiamo di voler creare un nuovo file contenente tutte le linee di @\'esempio.txt\'@ ma scritte al contrario. la funzione che ci serve per scriverle al contrario e\' @reverse()@, il modo pi&#249; semplice per farlo sarebbe: \r\n\r\n\r\n print File.new(\'esempio.txt\').map {|linea| linea.reverse}\r\n        \r\n\r\nPossiamo poi usare @map()@ per estrarre delle informazioni sugli oggetti, ad esempio, potremmo decidere di sapere qual\'&#232; la lunghezza delle linee del file: \r\n\r\n puts File.new(\'esempio.txt\').map {|linea| linea.length}\r\n\r\n\r\nIn generale, @map()@ e\' la soluzione migliore per molti problemi in linguaggi funzionali tipo il @LISP@. Ma la potenza e la chiarezza di questa funzione hanno fatto si che venisse _importata_ anche in altri sistemi, come ad esempio SmallTalk, python e ruby. \r\n\r\nRuby, grazie al sistema degli iteratori, fa si che a qualunque oggetto definisca una funzione @each()@ possa  rendere disponibile anche @map()@ facilmente.\r\n Ad esempio:\r\n\r\n >> class Tripla\r\n >>  def initialize(a,b,c)\r\n >>   @a,@b,@c=a,b,c\r\n >>  end\r\n >>  def each\r\n >>   yield @a\r\n >>   yield @b\r\n >>   yield @c\r\n >>  end\r\n >>  include Enumerable # ecco la magia!\r\n >> end\r\n => Tripla\r\n >> t=Tripla.new( 13,\'miao\',[1,2,3] )\r\n => #<Tripla:0x27f8b10 @b=\"miao\", @a=13, @c=[1, 2, 3]>\r\n >> t.map {|x| x * 2 }\r\n => [26, \"miaomiao\", [1, 2, 3, 1, 2, 3]]\r\n\r\n');
INSERT INTO `revisions` VALUES (110,64,16,'2005-11-25 13:01:16','h1.  Gabriele Renzi\r \n\r\nbeh, appassionato di ruby da qualche anno, incidentalmente ho scritto quei due o tre artticoletti per siforge. A differenza di altri nel gruppo non odio python ;)\n');
INSERT INTO `revisions` VALUES (111,65,16,'2005-11-25 13:01:16','h1.  XML via DOM\r \n\r\n_ php cookbok 12.3 _\r\n\r\n\r\nREXML, la libreria standard per la gestione dell\'XML in ruby mette a disposizione dell\'utente molte API diferenti: DOM,SAX,SAX2,PULL, piu\' le sue api caratteristiche.\r\n\r\nDOM e\' una api molto comune e diffusa, ma REXML se ne discosta leggermente, nel tentativo di rendere la vita piu\' semplice allo sviluppatore.\r\nAd esempio, per aggiungere un elemento ad un documento, usando DOM dovremmo scrivere:\r\n   element = document.createElement(\"pippo\")\r\n   current_element.appendChild(element)\r\n\r\nmentre con @REXML@ bastera\' scrivere:\r\n\r\n   current_element.add_element(\"pippo\")\r\n\r\nMa andiamo per gradi.\r\nAnzitutto creiamo un oggetto @REXML::Document@, poi lo manipoleremo aggiungendo dati ed infine ne effettueremo il @dump@ su una stringa. \r\nA quel punto sara\' banale stampare la stringa su un file.\r\n\r\nAnzitutto carichiamo il modulo @Document@ di @REXML@:\r\n >> require \'rexml/document\'\r\n => true\r\n\r\nPoi creiamo un oggetto @Document@:\r\n >> doc=REXML::Document.new\r\n => #<REXML::Document:22522284\r\n\r\nOra aggiungiamo un elemento radice:\r\n\r\n >> book=doc.add_element \'book\'\r\n => #<REXML::Element:0x2ae65e0 @name=\"book\", @elements=#<REXML::Elements:0x2ae64\r\n 0 @element=#<REXML::Element:0x2ae65e0 ...>>, @namespace=\"\", @context={}, @paren\r\n =#<REXML::Document:22495716, @expanded_name=\"book\", @prefix=\"\", @attributes={},\r\n @children=[]>\r\n\r\n_attenzione, il metodo @inspect()@ degli oggetti di @REXML@ da un output molto esteso, quindi ora lo eviteremo, lasciando solo il codice_\r\n\r\nOra aggiungiamo un titolo, settiamo un paio di atributi, ed inseriamo del testo:\r\n title=book.add_element \'title\'\r\n title.text= \'la mia paginetta del wiki\'\r\n title.attributes[\'cover\']=\'soft\'\r\n\r\nPer vedere l\'xml vi bastera\' trasformare il documento (o gli elementi) in stringa:\r\n >> doc.to_s\r\n => \"<book><title cover=\'soft\'>la mia paginetta del wiki</title></book>\r\n\r\nVolendo possiamo unire la creazione di elementi con l\'aggiunta di attributi, usando un @Hash@:\r\n (book.add_element \'title\', {\'cover\'=>\'soft\',\'isbn\'=>\'0123456789\'}).to_s\r\n \"<title isbn=\'0123456789\' cover=\'soft\'/>\"\r\n\r\nCreiamo ed aggiungiamo un paio di autori al libro:\r\n aut=book.add_element \'author\'\r\n aut.text=\'gabriele\'\r\n aut2=book.add_element \'author\'\r\n aut2.text=\'nicola\'\r\n\r\n\r\n\r\nSe volete stampare su un file usando una comoda indentazione, bastera\' scrivere:\r\n\r\n doc.write un_output,livello_indentazione\r\n\r\nAd esempio:\r\n  doc.write STDOUT, 2\r\n\r\n  <book>\r\n    <title cover=\'soft\'>la mia paginetta del wiki</title>\r\n    <author>gabriele</author>\r\n    <author>nicola</author>\r\n  </book>\r\n\r\n\r\nNote:\r\nUn pezzo di un documento XML  e\' detto nodo. Esistono molti tipi di nodi in un documento XML,ma generalmente ci si preoccupa di nodi testo, attributi ed elementi.\r\n\r\nOvviamente potreste, se lo desiderate, seguire un approccio uniforme alla creazione di un doicumento xml: crare oggetti @Element@, @Text@, @Attribute@ ed aggiungere man mano gli uni agli altri. \r\nMa ovviamente questo e\' un lavoro ripetitivo e lungo. \r\nDato che un nodo di tipo testo e\' poco piu\' di una stringa, e\' molto piu\' comodo scrivere direttamente \r\n mio_elemento.text = \'miotesto\'\r\n\r\nE dato che gli attributi sono coppie nome/valore, e\' possibile usare un @Hash@ per passarli al costruttore di un elemento. \r\n\r\n@REXML@ segue l\'approccio di ruby: rendere le cose semplici.\r\n');
INSERT INTO `revisions` VALUES (112,66,16,'2005-11-25 13:01:16','h1.  Giovanni Corriga\r \n\r\n');
INSERT INTO `revisions` VALUES (113,67,16,'2005-11-25 13:01:16','h1.  Gui con Tk\r \n\r\nTk e\' un toolkit diffusissimo ed usatissimo, in particolare da tcl,ruby, perl, e python.  \r\nTk non fornisce grandissime funzionalita\', ma ha dei vantaggi:\r\n * e\' disponibile su quasi ogni piattaforma esistente\r\n * e\' semplice\r\n * ha un aspetto nativo \r\n * ha degli ottimi binding per Ruby \r\nAlcune delle risorse per Ruby/Tk\r\n\r\nh1. == Documentazione online ed esempi\r \n * [[Ruby-Tk tutorial|URL:http://members.chello.nl/k.vangelder/ruby/learntk/hello.html]]\r\n * [[Esempi in Ruby-Tk ispirati da un libro giapponese|URL:http://www02.so-net.ne.jp/~greentea/ruby/ruby-tk/]]\r\n * [[Le pagine su Tk tratte da Programming Ruby |URL:http://www.rubycentral.com/book/ext_tk.html]]\r\n * [[Esempi comparati di Tcl e Ruby con Tk|URL:http://www2s.biglobe.ne.jp/~Nori/ruby/ja/tk-ref/]]\r\n * [[La documentazione di Tk|URL:http://www.tcl.tk/doc/]]\r\n * [[Ruby-Tk FAQ|URL:http://www.approximity.com/ruby/rubytk.html]]\r\n\r\n');
INSERT INTO `revisions` VALUES (114,68,16,'2005-11-25 13:01:16','h1.  Guide In Eng\r \n\r\nQuesti sono alcuni dei documenti in inglese reperibili su internet:\r\n\r\n* [[Learn To Program|URL:http://pine.fm/LearnToProgram/]]\r\nun tutorial per chi vuole imparare a programmare da zero\r\n* [[A little ruby a lot of objects|URL:http://www.visibleworkings.com/little-ruby/]]\r\nispirato al famosissimo \"little lisper\", in pratica un enorme domanda&risposta :)\r\n* [[Programming Ruby|URL:http://www.rubycentral.com/book/]]\r\n_Il_ manuale per definizione ;)\r\n* [[ An introduction to software craftmanship|URL:http://www.mcbreen.ab.ca/RubyForTheNubyDraft.pdf]]\r\nsi tratta di un libro particolare, in quanto punta a insegnare a programmare _bene_, usando ruby come linguaggio per gli esempi\r\n* [[Why\'s poignant guide to Ruby|URL:http://poignantguide.net/ruby/]]\r\nDovete leggerla. E\' una guida atipica, piena di fumetti, battute, colori e  \r\nimmaginazione. Un capolavoro.\r\n\r\n');
INSERT INTO `revisions` VALUES (115,69,16,'2005-11-25 13:01:16','h1.  GuideInIta\r \n\r\nNota: la seguente documentazione e\' stata tradotta da\r\n* Gianluigi Spagnuolo\r\n* Panther\r\n* Massimo Arnaudo\r\n* Gabriele Renzi\r\n* Aggiungete\r\n\r\nh1. = [[Ruby User Guide|URL:http://ada2.unipv.it/ruby/doc/rg.zip]]\r \nIl manuale del linguaggio, una panoramica su tutte le caratteristiche che fanno di Ruby un linguaggio eccezionale (italiano)\r\n\r\nh1. = [[Programming Ruby|URL:http://www.massimo.arnaudo.name/modules/mydownloads/visit.php?cid=2&lid=2]]\r \nLa Bibbia. Concetti fondamentali, Reference Manual, tips di implementazione, esempi d\'uso dell librerie.. (italiano, non completamente tradotta)\r\n\r\nh1. = [[Imparare Ruby|URL:http://savannah.nongnu.org/files/?group=ruby-tut]] \r \nUn ottimo tutorial per imparare a programmare. Non si limita come molti ad insegnare a scrivere codice, ma anche di usare _l\'approccio giusto_ alla scrittura (italiano)([[mirror|URL:http://ada2.unipv.it/~riffraff/beginner-it-0.1.tar.gz]])\r\n\r\nh1. =[[Ancora un Ruby Gnome Howto|URL:http://ada2.unipv.it/~riffraff/argh]]\r \nUna guida semplice per imparare a sviluppare applicazioni con ruby e le tecnologie Gnome-related come Gtk (ed in futuro GConf, GnomeCanvas, GStreamer..) (italiano) \r\n');
INSERT INTO `revisions` VALUES (116,70,16,'2005-11-25 13:01:16','h1.  HashInfinito\r \n\r\nCosa intendiamo per _hash infinito_ ?\r\nBeh si tratta di un oggetto in cui sin possa fare cosi\';:\r\n\r\n >> superhash[\'primo\']= \"alore\"\r\n => \"alore\"\r\n >> superhash[\'due\'][\'livelli\']\r\n => {}\r\n >> superhash[\'due\'][\'livelli\']= \'ciao\'\r\n => \"ciao\"\r\n >> superhash\r\n => {\"primo\"=>\"alore\", \"due\"=>{\"livelli\"=>\"ciao\"}}\r\n >> superhash[:tutti][:i][\'livelli\'][\'che\'][\"desiderate\"]= \"bau\"\r\n => \"bau\"\r\n >> superhash\r\n => {\"primo\"=>\"alore\",\"due\"=>{\"livelli\"=>\"ciao\"},\r\n      :tutti=>{:i=>{\"livelli\"=>{\"che\"=>{\"desiderate\"=>\"bau\"}}}}}\r\n\r\nIn pratica simula quello che in letteratura viene detto _sparse Array multidimensionale\'_ cioe\' un @Array@ in cui solo pochi degli elementi hanno un valore. \r\n\r\nAd esempio, pensate a dover gestire un cinema. \r\nUserete una matrice per i posti, quindi ogni posto sara\' @sala[fila][seggiolino]@. \r\nMa sapete che il vostro film trasmette solo musical postrealisti del tagikistan, e nel vostro quartiere ci sono pochi cinefili, quindi avrete pochi utenti. \r\nNon conviene mantenere un\'intera matrice.\r\nCi bastera\' usare il nostro superhash. \r\n\r\nPer crearlo farete cosi\';:\r\n\r\n >> hash_maker = proc do |h, k|\r\n ?>    h[k] = Hash.new(&hash_maker)\r\n >> end\r\n => #<Proc:0x027d1520@(irb):1>\r\n >> sala=Hash.new &hash_maker\r\n => {}\r\n\r\nOra potete assegnare i posti che volete:\r\n\r\n >> sala[0][1]=\'signor rossi\'\r\n => \"signor rossi\"\r\n >> sala[2][20]=\'signora bianchi\'\r\n => \"signora bianchi\"\r\n >> sala[5][12]=\'signor mori\'\r\n => \"signor mori\"\r\n >> sala.size\r\n => 3\r\n\r\nAbbiamo usato solo lo spazio che ci serviva.\r\n\r\nMa spieghiamo il trucco:\r\n\r\nUn @Hash@ puo\' essere creato con un valore predefinito, che e\' il risultato di un blocco passato al costruttore @new()@. Possiamo fare questa cosa amnche con gli @Array@ ed e\' molto utile perche\' ci permette di inizializzare questi oggetti quando li costruiamo, invece di usare due operazioni separate.\r\n\r\nPoiche\' un @Hash@ non ha dimensione fissata non possiamo calcolare a priori i valori come, cosa che avviene invece con @Array.new block@:\r\n >> x=0\r\n => 0\r\n >> ary=Array.new(10) { x+=1 }\r\n => [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\r\n\r\n Dunque la procedura (nel nostro caso hash_maker) viene richiamata quando \r\n accediamo ad una chiave che non e\' gia stata creata. Ad esempio:\r\n\r\n >> hsh=Hash.new {|hash,kiave| hash[kiave]=x+=1  }\r\n => {}\r\n >> hsh[:a]\r\n => 11\r\n >> hsh[:s]\r\n => 12\r\n >> hsh[29]\r\n => 13\r\n \r\n(spero sia chiaro che proseguiamo l\'esempio di prima :P)\r\n\r\nNel nostro caso abbiamo usato una procedura, @hash_maker@ che ogni volta crea un nuovo @Hash@ con se stessa come valore di default, permettendo di aggiungere infiniti livelli. Fico vero?\r\n\r\nAh, se non lo sapeste, scrivere @&oggetto_di_tipo_procedura@ serve a dire a ruby _espandi questo blocco, come se avessi scritto @do..end@ in questo punto_\r\n\r\n');
INSERT INTO `revisions` VALUES (117,71,16,'2005-11-25 13:01:16','h1.  HashJavaScriptLike\r \n\r\nJavaScript possiede, come molti linguaggi di alto livello, una struttura dati rappresentante un Hash/dizionario.\r\n\r\nUn hash viene creato e si usa piu\' o meno come in ruby:\r\n\r\n var mioHash = {};\r\n mioHash[\"kiave\"] = \"valore\";\r\n\r\nMa, nel caso la chiave sia una stringa valida anche come identificatore (cioe\' se contiene solo valori alfanumerici e \"@_@\") si puo\' usare questa sintassi:\r\n\r\n mioHash.kiave = \"valore\";\r\n\r\nIn ruby, questo comportamento e\' molto semplice da ottenere, usando @method_missing()@.\r\nIl metodo @method_missing()@, se definito in una classe, viene richiamato ogni volta che su di un\'istanza di quella classe viene richiamato un metodo che non esiste.\r\nCome parametri gli vengono passati:\r\n (1) un simbolo rappresentante il nome del metodo\r\n (2) un array contenente i parametri passati al metodo\r\n (3) un eventuale blocco passato al metodo\r\n\r\nAd esempio:\r\n >> class Mia\r\n >>  def method_missing(sym,*args,&blk)\r\n >>    puts \'chiamato: \'+sym.to_s\r\n >>    puts \'con argomenti: \'+args.inspect\r\n >>    puts \'ed un blocco\' if blk\r\n >>  end\r\n >> end\r\n => nil\r\n >> m=Mia.new\r\n => #<Mia:0x27762c8>\r\n >> m.ciao\r\n chiamato: ciao\r\n con argomenti: []\r\n => nil\r\n >> m.ciao 1 ,2 ,3\r\n chiamato: ciao\r\n con argomenti: [1, 2, 3]\r\n => nil\r\n >> m.ciao(1 ,2 ,3) { lol }\r\n chiamato: ciao\r\n con argomenti: [1, 2, 3]\r\n ed un blocco\r\n => nil\r\n\r\n\r\nDunque, ci basta definire questo metodo in  maniera appropriata per la class @Hash@:\r\n\r\n >> class Hash\r\n >>  def method_missing(sym,*args,&blk)\r\n >>    self[sym.to_s]\r\n >>  end\r\n >> end\r\n => nil\r\n >> hsh={}\r\n => {}\r\n >> hsh[\'ciao\']=\'bau\'\r\n => \"bau\"\r\n >> hsh.ciao\r\n => \"bau\"\r\n');
INSERT INTO `revisions` VALUES (118,72,16,'2005-11-25 13:01:16','h1.  HashPythonLike\r \n\r\nUn @Hash@ in python si chiama _dict_ ma funziona in maniera quasi identica a\r\nquelli di ruby. La differenza fondamentale e\' nel fatto che quando  cercate un elemento\r\nche non e\' stato ancora inserito ottenete un\'eccezione invece di @nil@.\r\n\r\nin ruby: \r\n >> hsh=Hash.new\r\n => {}\r\n >> hsh[0]\r\n => nil\r\n\r\nin python:\r\n >>> hsh=dict()\r\n >>> hsh[0]\r\n Traceback (most recent call last):\r\n   File \"<stdin>\", line 1, in ?\r\n KeyError: 0\r\n\r\nfortunatamente, in entrambi i linguaggi possiamo creare delle _sottoclassi_\r\nche si comportino diversamente. \r\nIn ruby, pero\';, possiamo evitare di farlo, creando un @Hash@ che si comporti come desideriamo.\r\n\r\nInfatti ruby ci permette di associare come valore di default di un @Hash@ una procedura, un blocco @do..end@, che verra\' eseguito ogni volta che richiamiamo una chiave non precedentemente definita. Il metodo e\' semplicissimo:\r\n\r\n >> hsh=Hash.new {   raise \'Errore!\' }\r\n => {}\r\n >> hsh[0]\r\n RuntimeError: Errore!\r\n         from (irb):31\r\n         from (irb):31:in `call\'\r\n         from (irb):32:in `default\'\r\n         from (irb):32:in `[]\'\r\n         from (irb):32\r\n         from &#9829;:0\r\n >> hsh[2]\r\n RuntimeError: Errore!\r\n         from (irb):31\r\n         from (irb):31:in `call\'\r\n         from (irb):33:in `default\'\r\n         from (irb):33:in `[]\'\r\n         from (irb):33\r\n         from &#9829;:0\r\n\r\nOvviamente, se voleste fare le cose meglio potrest creare una classe @KeyError@ , ma lascio a voi il piacere :)\n');
INSERT INTO `revisions` VALUES (119,73,16,'2005-11-25 13:01:16','h1.  HOF\r \n\r\nCosa e\' una Funzione di Ordine Superiore (Higher Order Function)? \r\nUna funzione di ordine superiore e\' una funzione che manipola dei dati speciali.. delle altre funzioni :)\r\n\r\nPrima di addentrarvi nella lettura fareste bene a leggere [[l\'introduzione agli oggetti funzione|OggettiProcEMethod]]\r\n\r\nSi parla molto spesso di _astrazione_ riferendosi ad un buono stile di programmazione.\r\n\r\n\r\nAd esempio, dovendo scrivere funzioni per calcolare il doppio di 3 e 4, questo stile:\r\n def doppio_3\r\n  6\r\n end\r\n def doppio_4\r\n  8\r\n end\r\n\r\nSarebbe considerato straordinariamente stupido.\r\nLa soluzione corretta sarebbe: conservare la logica in un punto, e lasciare la definizione dei dati all\'utente:\r\n def doppio(num)\r\n  num*2\r\n end\r\n\r\n\r\nNei linguaggi che permettono la manipolazione di funzioni, e\' facile arrivare all\'idea che \r\nanche alcune parti della logica possono essere definite dall\'utente. \r\nAd esempio, volendo scrivere un sistema che cerchi un libro in una biblioteca:\r\n\r\nstile idiota:\r\n def cerca_promessi_sposi\r\n  return promessi_sposi\r\n end\r\n def cerca_divina_commedia\r\n  return divina_commedia\r\n end\r\n ...\r\nstile normale\r\n def cerca_per_titolo(titolo)\r\n  for i in libri\r\n   return i if i.titolo=titolo\r\n  end\r\n end\r\n\r\n def cerca_per_ISBN(codice)\r\n  for i in libri\r\n   return i if i.isbn=codice\r\n  end\r\n end\r\n ...\r\nstile funzionale, piu\' astratto:\r\n\r\n def cerca_per(funzione_chiave)\r\n  for i in libri\r\n   return if funzione_chiave(i)\r\n  end\r\n end\r\n\r\nI sistema iteratori/blocchi in ruby serve esattamente a questo scopo. Esempi classici sono @map()@ , @find()@, @sort_by()@..\r\n\r\nLe trasformazioni e le funzioni di analisi che possiamo applicare ad un Enumerable con queste funzioni.. sono infinite. D\'altronde, riempire il blocco con una decina di funzioni puo\' risultare in codice poco chiaro, o poco elegante. \r\nLa soluzione funzionale e\' la generazione di altre funzioni Vediamo un esempio d\'uso di @reject()@, che funziona esattamente al contrario di @select()@ \r\n\r\nNota:\r\nusiamo degli oggetti Proc invece di normali funzioni. \r\n \r\n\r\n\r\n >> lunga= proc do |x|\r\n ?>  x.length > 5\r\n >> end\r\n => #<Proc:0x401e9df0@(irb):1>\r\n >>\r\n ?> numerica=proc do |linea|\r\n ?>  /[0-9]/.match(linea)\r\n >> end\r\n => #<Proc:0x401e5908@(irb):5>\r\n >>  puts  File.new(\'esempio.txt\').reject(&lunga).reject(&numerica)\r\n => nil\r\n >>  puts  File.new(\'esempio.txt\').reject(&lunga).select(&numerica)\r\n la 3\r\n => nil\r\n        \r\nVisto come abbiamo combinato @reject()@ e @find_all()@ ?\r\nPossiamo farlo infinite volte, fino a scrivere linee anche molto complesse. Per evitare di scrivere codice completamente incomprensibile, puo\' essere una buona idea usare delle funzioni generate al volo come composizione di altre. Una funzione che manipoli altre funzioni invece di comuni dati viene detta Higher Order Function, cioe\' funzione di ordine superiore. Come esempio, scriviamo @both(x,y)@ che accetta in input due funzioni semplici e ne restituisce una nuova, combinazione di entrambe (both, appunto): \r\n\r\n both= proc do |funz_a,funz_b|\r\n        proc do |x|\r\n         funz_a[x] and funz_b[x]\r\n        end\r\n      end\r\n\r\n lunga= proc do |x|\r\n        x.length > 5\r\n       end\r\n\r\n numerica= proc do |linea|\r\n           /[0-9]/.match(linea)\r\n          end\r\n\r\n lung_num=both[lunga,numerica]\r\n\r\n puts File.new(\'esempio.txt\').select(&lung_num)  \r\n        \r\n\r\nCon le HFO potete modellare problemi anche molto complessi mantenendo sempre una buona chiarezza descrittiva. In ruby non le userete molto, poiche\' che i blocchi in ruby rendono particolarmente naturale scrivere la funzione \"al volo\". e rendono meno intuitive le HFO. Perche\' invece in LISP, ad esempio, cio\' rimane piu\' naturale? \r\nSemplice, perche\' i blocchi in ruby rappresentano una [[forma lambda|FormaLambda]], e mentre in lisp e\' piu\' semplice combinare funzioni che scrivere forme lambda ogni volta, in ruby e\' il contrario. Ad ogni modo, e\' interessante notare che il meccanismo di ruby nasce proprio come evoluzione di quello di LISP/Scheme, unito al meccanismo dei blocchi di SmallTalk.\r\n\r\nAnche se ruby non e\' un linguaggio funzionale, e\' affascinante vedere quanto possa essere flessibile.\r\nVediamo un esempio. Supponiamo di avere un file strutturato in questa maniera: \r\n\r\n #nome matricola anno_di_nascita sesso\r\n Gabriele 09101234 1980 M\r\n Elena 12120987 1986 F\r\n Nicola 12543211 1985 M\r\n Filippo 98762211 1953 M\r\n # commenti che iniziano per #\r\n Lorenzo 62617171 1990 M\r\n Costanza 01919111 1970 F\r\n Silvia 12679012 1979 F\r\n #Silvia 12679012 1079 F\r\n\r\n            \r\nDobbiamo scrivere un programma che trovi tutte le femmine nate prima del 1980 e tutti i maschi nati dopo o nel 1980, ovviamente ignorando le linee di commento, cioe\' quelle che cominciano con un \"#\". Dunque, ragioniamo per gradi: \r\n\r\nabbiamo bisogno di una funzione che identifichi le linee commentate: @is_comm()@\r\ndi due funzioni per il sesso: @is_M()@ e @is_F()@\r\ndi una per i nati prima del 1980 @is_pre_1980()@\r\ne di una per i nati dopo il 1979 @is_post_1979()@\r\nTranquilli, e\' piu\' semplice di quel che sembra usando @reject()@ , @find_all()@ e @map()@ (usiamo anche delle piccole HOF generiche..) \r\n\r\n # le nostre funzioncine di ordine superiore, le aggiungiamo come\r\n # metodi della classe Proc                \r\n class Proc\r\n  def not!\r\n   proc do |x|\r\n    not self[x]\r\n   end\r\n  end\r\n\r\n\r\n  def and(fun_b)\r\n   proc do |x|\r\n    self[x] and fun_b[x]\r\n   end\r\n  end\r\n\r\n  def or(fun_b)\r\n   proc do |x|\r\n    self[x] or fun_b[x]\r\n   end\r\n  end\r\n end\r\n\r\nQueste sono funzioni generali, che secondo me sono comode, ma delle quali si puo\' fare a meno.. ed ecco il codice effettivo: \r\n\r\n\r\n is_comm     = proc { |linea| linea[0].chr == \'#\' }\r\n is_M        = proc { |lin|  lin[-2].chr == \'M\' }\r\n pre_1980    = proc { |lin| (lin.split[2]).to_i  < 1980 }\r\n\r\n is_F        = is_M.not!\r\n post_1980   = pre_1980.not!\r\n\r\n ok          = is_F.and(pre_1980).or is_M.and(post_1980)\r\n\r\n puts File.new(\'dati.txt\').reject(&is_comm).find_all(&ok)\r\n\r\nLa versione imperativa sarebbe: \r\n\r\n \r\n res=[]\r\n f=File.new(\'dati.txt\')\r\n  for l in f do\r\n   if not l[0].chr ==\'#\'\r\n    if l[-2].chr == \'M\'\r\n    if l.split[2].to_i>=1980\r\n      res.push(l)\r\n     end\r\n    else\r\n     if l.split[2].to_i> 1980\r\n      res.push(l)\r\n     end\r\n    end\r\n   end\r\n end\r\n    \r\n f.close\r\n puts  res\r\n\r\nA voi la decisione su quale approccio sia piu\' chiaro, e meno propenso a farvi commettere errori. \r\nAvete scelto? Ora cercate di capire che modifiche accadrebbero se doveste aggiungere una funzione che restituisca maschi e femmine nati prima del 1980 e con matricola che inizia per \r\n\'091\'. Quale approccio vi sembra migliore?\r\nOvviamente siete liberi di scegliere un approccio ibrido ;). \r\n\r\n\r\n\r\nUn ultima nota: noi abbiamo definito delle funzioni di ordine superiore molto semplici, ma si possono definire strutture molto complesse. Se ne avete voglia sarebbe interessante un poorting delle funzioni definite in [[OnLisp|URL:http://www.paulgraham.com/onlisp.html]], anche se potreste scoprire che ruby include gia\' parecchio del Common LISP :-)\r\n\r\n--\r\nUn\'esempio di HOF piuttosto utile: [[memoize|Quiz Aprile 2003]]\r\n');
INSERT INTO `revisions` VALUES (120,75,16,'2005-11-25 13:01:16','h1.  id\r \n\r\n');
INSERT INTO `revisions` VALUES (121,76,16,'2005-11-25 13:01:16','\nDir[\'*.rd\']\n\n');
INSERT INTO `revisions` VALUES (124,79,16,'2005-11-25 13:01:16','h1.  Info \n');
INSERT INTO `revisions` VALUES (125,80,16,'2005-11-25 13:01:16','h1.  Init condizionato\r \n\r\n\r\nIn alcuni casi e\' necessario assegnare un valore ad una variabile solamente nel caso che non sia gia\' stata definita in modo differente. Ad esempio, lavorando con il web potrebbe essere necessario impostare il nome dell\'utente online in un certo momento, ma non sovrascrivelo ogni volta. \r\n\r\nLa soluzione piu\' ovvia e\':\r\n >> a=10\r\n => 10\r\n >> a= a || 20\r\n => 10\r\n >> b= b || 20\r\n => 20\r\n\r\nma poiche\' gli operatori possono essere combinati con l\'assegnazione:\r\n\r\n >> a ||= 20\r\n => 10\r\n >> b ||= 30\r\n => 20\r\n >> c ||= 40\r\n => 40\r\n >> [a,b,c]\r\n => [10, 20, 40]\r\n\r\nOvviamente pero\' se la variabile ha come valore @false@ o @nil@ essa verra\' sovrascritta con il nuovo valore. In generale questo e\' quello che vogliamo, ma in caso contrario possiamo usare @defined?@ per chiedere a ruby se, appunto, la variabile e\' stata definita:\r\n\r\n >> pippo\r\n NameError: undefined local variable or method `pippo\' for main:Object\r\n >> if not defined? pippo\r\n >>  pippo=30\r\n >> end\r\n => 30\r\n >> pippo\r\n => 30\r\n\r\novviamente potete fare lo stesso per le variabili globali o di istanza. \r\n\r\n\r\n');
INSERT INTO `revisions` VALUES (126,81,16,'2005-11-25 13:01:16','h1.  IterareInParallelo\r \n\r\nQuello di cui avete bisogno e\' @Enumerable#zip()@\r\n\r\nAd esempio: \r\n for i,j in [1,2,3,4].zip([8,7,6,5])\r\n  puts i+j\r\n end\r\n 9\r\n 9\r\n 9\r\n 9\r\n\r\nfacile facile\r\n');
INSERT INTO `revisions` VALUES (127,82,16,'2005-11-25 13:01:16','h1.  IterareSequenze\r \n\r\nPuo\' capitare di dover effettuare un\'iterazione su piu\' elementi per volta in una sequenza. \r\n\r\nAd esempio, per creare una galleria di immagini, avrebbe senso avere accesso contemporaneamente sia ad un elemento @i@ che agli elementi @i+1@ e @i-1@, per poter creare dei link tipo \"@<<prev@\" e \"@next>>@\"\r\nIn un linguaggio C-like si userebbe l\'indice @i@ esplicitamente, ma come gestire questo in un linguaggio dove l\'iterazione e\' implicita? Un metodo sarebbe quello di usare una variabile esterna al ciclo:\r\n\r\n >> count=0\r\n => 0\r\n >> ary= [1,2,3,4,5,6,7,8]\r\n => [1, 2, 3, 4, 5, 6, 7, 8]\r\n >> for i in ary\r\n >>  print ary[count-1],i,ary[count+1],\"\\n\"\r\n >>  count+=1\r\n >> end\r\n 812\r\n 123\r\n 234\r\n 345\r\n 456\r\n 567\r\n 678\r\n 78nil\r\n => [1, 2, 3, 4, 5, 6, 7, 8]\r\n\r\nQuesto metodo e\' poco elegante ed inconsistente, ad esempio nel primo ciclo dovremmo controllare che si tratti del primo, per non usare un elemento con indice minore di zero, e nell\'ultimo per non usarne uno fuori dall\'@Array@. \r\nMa ruby non e\' un linguaggio inconsistente ed inelegante, dunque vediamo come miglirare un po\' la cosa.\r\n\r\nAnzitutto, possiamo usare @each_with_index()@, e liberarci di quella brutta variabile esterna:\r\n >> ary.each_with_index do |el,i|\r\n ?>  print ary[i-1],el,ary[i+1],\"\\n\"\r\n >> end\r\n 812\r\n 123\r\n 234\r\n 345\r\n 456\r\n 567\r\n 678\r\n 78nil\r\n => [1, 2, 3, 4, 5, 6, 7, 8]\r\n\r\nLeggermente meglio, na ancora abbiamo il problema di controllare il ciclo iniziale e finale.. Sarebbe meglio se potessimo dire a ruby: \"_dammi @n@ elementi consecutivi_\".\r\nIn effetti, possiamo farlo, usando il modulo @enumerator@, incluso nella libreria standard:\r\n >> require \'enumerator\'\r\n => true\r\n >> ary.each_cons(3) do |pre,el,suc|\r\n ?>   print pre,el,suc,\"\\n\"\r\n >> end\r\n 123\r\n 234\r\n 345\r\n 456\r\n 567\r\n 678\r\n => nil\r\n\r\nPerfetto!\r\nMa cosa e\' successo ? Semplice, @enumerator@ aggiunge alcuni metodi utili al modulo @Enumerable@ e di conseguenza alla classe @Array@. \r\nTra questi metodi esiste il comodissimo @each_cons( )@ che richiama il blocco ogni volta con una sequenza di @n@ elementi, in questo caso @n=3@. \r\n\r\nNessun bisogno di gestire casi particolari o di scrivere codice brutto ed error prone, abbiamo tutto gia\' pronto.\r\n');
INSERT INTO `revisions` VALUES (128,83,16,'2005-11-25 13:01:16','h1.  IteratoriEsterni\r \n\r\ncos\'e un Iteratore?\r\nSi tratta di un meccanismo che ci permette di lavorare in sequenza su tutti gli elementi contenuti in una collezione. In ruby, gli iteratori sono tutti quelli accettano un blocco, come @each()@, @map()@ eccetera. \r\nIn linguaggi sfortunati che non hanno a disposizione  funzioni anonime e la keyword @yield@, questo comportameto viene costruito tramite l\'[[Iterator Pattern|URL:http://c2.com/cgi/wiki?IteratorPattern]]. \r\n\r\nL\'iterator pattern e\' un meccanismo semplice, in sostanza un oggetto deve mettere a disposizione due metodi\r\n (1) uno che permetta di accedere al prossimo elemento, tipicamente chiamto @next()@\r\n (2) ed uno che permetta di testare l\'esistenza di un elemento successivo, \r\n\r\nIn ruby, e\' possibile ovviamente implementare questo meccanismo , [[quest ne e\' un esempio|URL:http://rubycolor.org/dp/Iterator.en.html]], \r\n\r\nMa non solo, e\' molto semplice usare uno degli iteratori _interni_ cioe\' quelli che usano @yield@ trasformandolo in esterno, tramite la libreria @generator@.\r\n\r\nVediamo un\'esempio:\r\n\r\n irb(main):001:0> require \'generator\'\r\n => true\r\n irb(main):002:0> a=[1,3,5,7,9] # un Array, un oggetto Enumerable\r\n => [1, 3, 5, 7, 9]\r\n irb(main):003:0> g=Generator.new a\r\n => #<Generator:0x27dcd40 @queue=[1], @cont_endp=nil, @index=0, @block=#<Proc:0x\r\n 27db600@C:/Programmi/ruby-1.8/ruby/lib/ruby/1.8/generator.rb:69>, @cont_yield=#\r\n Continuation:0x27dca70>, @cont_next=nil>\r\n irb(main):004:0> g.current\r\n => 1\r\n irb(main):005:0> g.next\r\n => 1\r\n irb(main):006:0> g.next\r\n => 3\r\n irb(main):007:0> g.next\r\n => 5\r\n irb(main):008:0> g.next?\r\n => true\r\n irb(main):009:0> g.next\r\n => 7\r\n irb(main):010:0> g.next?\r\n => true\r\n irb(main):011:0> g.next\r\n => 9\r\n irb(main):012:0> g.next?\r\n => false\r\n \r\n\r\nUn @Generator@ viene creato passandogli un oggetto che implementi il metodo @each()@. \r\nCome potete vedere  il suo uso e\' piuttosto ovvio. \r\nPotete vederne la documentazione dettagliata [[qui|URL:http://www.ruby-doc.org/stdlib/libdoc/generator/rdoc/index.html]] o se avete una versione recente di ruby, direttamente nella sua directory della documentazione.\n');
INSERT INTO `revisions` VALUES (129,84,16,'2005-11-25 13:01:16','h1.  IteratoriPersonalizzati\r \n\r\nAlcune classi, ad esempio @String@ mettono a disposizione differenti modi per iterare. Nel caso di @String@ abbiamo @each_byte()@ e @each_line()@.\r\nIl metodo @each()@ di @String@ e\' un alias per @each_line()@.\r\nPoiche\' in questa classe e\' stato incluso il modulo @Enumerable@, possiamo usare tutte le funzioni come @max()@ o @map()@, ma ovviamente l\'iteratore alla base sara\' @each_line()@. \r\n\r\nVediamo un esempio:\r\n >> stringa=\"\r\n Quant\'&#232; bella giovinezza\r\n che si fugge tuttavia!\r\n Chi vuol esser lieto, sia:\r\n di doman non c\'&#232; certezza.\r\n \"\r\n => \"\\nQuant\'\\212 bella giovinezza\\nche si fugge tuttavia!\\nChi vuol esser lieto,\r\n  sia:\\ndi doman non c\'\\212 certezza.\\n\"\r\n >> puts stringa.sort #lavora con each, quindi con le linee\r\n\r\n Chi vuol esser lieto, sia:\r\n Quant\'&#232; bella giovinezza\r\n che si fugge tuttavia!\r\n di doman non c\'&#232; certezza.\r\n => nil\r\n\r\nCome fare per usare @sort()@ o @max()@, insomma i metodi di @Enumerable@ usando @each_byte()@ ?\r\nLa soluzione e\' usare un oggetto @Enumerator@:\r\n >> require \'enumerator\'\r\n => true\r\n >> e=Enumerable::Enumerator.new( stringa, :each_byte\r\n => #<Enumerable::Enumerator:0x27c4a70>\r\n >> e.min\r\n => 1o\r\n\r\nil @10@ e\' dovuto al fatto che lavoriamo su byte non su caratteri, e sarebbe lo \"\\n\".\r\n\r\nCome vedete l\'uso di @Enumerator@ e\' semplicissimo: per creare uno di questi oggetti basta usare un oggetto @Enumerable@, ed il simbolo che rappresenta il metodo da usare come iteratore. Una volta creato possiamo usarlo per iterare come ci pare, avendo a disposozione tutti i metodi di @Enumerable@. \r\n\r\nRicordate che non stiamo piu\' usando una stringa!\r\n\r\n >> e + \'miao\'\r\n NoMethodError: undefined method `+\' for #<Enumerable::Enumerator:0x27c4a70>\r\n         from (irb):17\r\n\r\n\r\n\r\n\r\n');
INSERT INTO `revisions` VALUES (130,85,16,'2005-11-25 13:01:16','h1.  LeggereFileCompressi\r \n\r\nRuby fornisce di default una pratica estensione per utilizzare @Zlib@, e tra le classi fornite da questo module esiste una semplicissima classe  @GzipReader@ che offre un\'api compatibile con altri normali oggetti @IO@. Ad esempio:\r\n\r\n >> require \'zlib\'\r\n => true\r\n >> Zlib::GzipReader.open(\'file.txt.gz\') do |io|\r\n ?>  puts io.readlines\r\n >> end\r\n ciao\r\n miao\r\n bau\r\n\r\nIl modulo @Zlib@ contiene molte altre cosette interessanti, e miracolosamente e\' pure documentato :D\n');
INSERT INTO `revisions` VALUES (131,86,16,'2005-11-25 13:01:16','h1.  LeggereFileUnParagrafoAllavolta\r \n\r\nSe venite da linguaggi come python o java a questo punto avrete gi&#224; in mente una decina di righe di codice\r\n\r\nreadlines(\'.\\n\') o \"\\n\\n\" \r\n_finire_\n');
INSERT INTO `revisions` VALUES (132,87,16,'2005-11-25 13:01:16','h1.  Leggere Metadati\r \n\r\n\r\n\r\nSupponiamo di voler ottenere da un file attributi come la data di creazione o i suoi permessi.\r\n\r\nIl metodo @File.stat()@ restituisce un oggetto della classe @File::Stat@:\r\n \r\n\r\n >> stat=File.stat \'plt-prefs.ss\'\r\n => #<File::Stat dev=0x2, ino=0, mode=0100644, nlink=1, uid=0, gid=0, rdev=0x2, s\r\n ize=6194, blksize=nil, blocks=nil, atime=Fri Mar 19 18:17:25 ora solare Europa o\r\n ccidentale 2004, mtime=Tue May 06 23:50:07 ora legale Europa occidentale 2003, c\r\n time=Tue May 06 23:50:07 ora legale Europa occidentale 2003>\r\n \r\n\r\nQuesto oggetto contiene un bel po\' di informazioni, mantenute in oggetti aprropriati. Ad esempio,  il metodo @size@ ci restituira\' la dimensione come umero intero, mentre @atime@ ci dira\' il tempo dell\'ultimo accesso al file tramite un oggetto di claqsse @Time@.\r\n\r\n\r\nLe proprieta\' di un oggetto @File::stat@ e quindi di un @File@ in generale, sono parecchie, fare riferimento a [[ri]] per maggiori informazioni. \r\n\r\nL\'uso e\' semplicissimo ed intuitivo:\r\n >> stat.atime\r\n => Fri Mar 19 18:17:25 ora solare Europa occidentale 2004\r\n >> stat.readable?\r\n => true\r\n >> stat.symlink?\r\n => false\r\n');
INSERT INTO `revisions` VALUES (133,89,16,'2005-11-25 13:01:16','h1. == Ruby\r \nbeh, la home page :)\r\n[[link|URL:http://www.ruby-lang.org]]\r\n\r\nh1. == RubyGarden\r \nUna home che funziona come piccolo portale per mini articoletti \r\ne soprattutto il contenitore del wiki della comunita\'\r\n[[link|URL:http://www.rubygarden.org]]\r\n\r\nh1. == RedHanded\r \nUn miniportale di news in stile delirante\r\n[[link|URL:http://redhanded.hobix.com]]\r\n\r\nh1. == RubyCentral\r \nUn associazione non profit che si occupa dello sviluppo di ruby, organizza, tra le altre cose, la RubyConf americana.\r\n[[link|URL:http://www.rubycentral.org]]\r\n\r\n\r\nh1. == RubyForge\r \nUn sito sourceforge-like che contiene qualche centinaio di progetti relativi a ruby, dalle librerie alle applicazioni, dai moduli enormi ai ritagli di codice piu\' piccoli. Funziona anche come punto di distribuzione centrale per i pacchetti [[RubyGems]]\r\n[[link|URL:http://www.rubyforge.org]]\r\n\r\nh1. == RubyDoc\r \nCome suggerisce il nome, il sito che vuole essere il punto di riferimento per la documentazione relativa a ruby. Contiene la dpocumentazione delle classi base e della libreria standard navigabile online.\r\n[[link|URL:http://www.ruby-doc.org]]\n');
INSERT INTO `revisions` VALUES (134,90,16,'2005-11-25 13:01:16','h1.  list \n');
INSERT INTO `revisions` VALUES (135,92,16,'2005-11-25 13:01:16','h1.  Luigi Panzeri\r \n\r\nNel 2002 inizio a leggere per curiosita\' \'Programming Ruby\' sul web. L\'introduzione mi prende, piu\' che per i contenuti, per l\'entusiasmo che trasmette. Leggo tutto il libro, addirittura ne compro una versione usata su Amazon. Al tempo ero consulente per una sw house e quando potevo realizzavo script in Ruby. Il tempo di sviluppo era drasticamente ridotto e mi riusciva naturale e spontaneo scrivere in Ruby scriptini di amministrazione. Con il tempo ho approfondito anche gli aspetti piu\' avanzati del linguaggio, scritto alcune [[slides|URL:http://ada2.unipv.it/~matley/rubytalk]] presentate al LD di Pavia. Grazie a Google conosco e vengo contattato da altri programmatori Ruby italiani. Offro, quindi lo spazio web ed installo il ruby wiki, sui cui si autocostruisce questo gruppo di utenti, che conta ormai 45 persone in Mailing List.  \r\n  \r\n[[La mia pagina personale|URL: http://ada2.unipv.it/~matley]]\n');
INSERT INTO `revisions` VALUES (136,93,16,'2005-11-25 13:01:16','h1.  map\r \n\r\n');
INSERT INTO `revisions` VALUES (137,94,16,'2005-11-25 13:01:16','h1.  Marshal\r \n\r\nIl _Marshalling _ e\' la procedura che permette di serializzare dei dati contenuti in un programma, avendo dunque la possibilita\' di salvarli su un file o in un database o di trasmetterli via Internet. \r\nQuesta funzionalita\' esiste in quasi ogni linguaggio, ed in ruby e\' implementata nel modulo @Marshal@. \r\n\r\nQuesto modulo offre due metodi decisamente intuitivi:\r\n * @Marshal#dump()@\r\n * @Marshal#load()@\r\n\r\nIl primo trasforma un oggetto in una stringa, o lo scrivo su di un oggetto @IO@.\r\nIl secondo accetta un oggetto @IO@ o uno che risponda al metodo @to_str()@, cioe\' che puo\' essere trasformato in stringa a letto.\r\n\r\nIn generale @Marshal@ e\' in grado di serializzare quasi tutto quello che desiderate, con l\'eccezione degli oggetti @Proc@, in maniera del tutto automatica:\r\n\r\n >> class Mia\r\n >>  def initialize(a)\r\n >>   @a=a\r\n >>  end\r\n >> end\r\n => nil\r\n >> m=Mia.new 10\r\n => #<Mia:0x27cc258 @a=10>\r\n >> str= Marshal.dump m\r\n => \"\\004\\010o:\\010Mia\\006:\\a@ai\\017\"\r\n >> Marshal.load str\r\n => #<Mia:0x27c7a40 @a=10>\r\n\r\nNotate che i due oggetti _non_ sono lo stesso, anche se sono uguali. \r\n\r\n');
INSERT INTO `revisions` VALUES (138,95,16,'2005-11-25 13:01:16','h1.  Pseudo-Keyword\r \n\r\nCosa intendiamo per pseudokeyword?\r\n\r\nTutti quelle parole che in qualche modo sembrano far parte della sintassi,\r\ne che spesso in altri linguaggi sono appunto delle keyword, ma che in ruby \r\nsono semplicemente dei metodi.\r\n\r\nIl primo e piu\' ovvio esempio e\' quello dei metodi d\'accesso @attr()@ e gli altri:\r\n class C\r\n  attr_accessor :var\r\n end\r\n\r\nIn realta\' @attr_accessor@ e\' un normalisimo metodo, che prende in input un simbolo e tramite @eval()@ definisce altri metodi. Questo metodo _assomiglia_ ad una keyword perche\' \r\n * funziona in modo dichiarativo\r\n * non usa parentesi\r\n \r\nPuo\' sembrare stupido ma la differenza tra molte keyword e dei normali metodi e\' nel loro _aspetto dichiarativo_.\r\n\r\nCosa si intende per dichiarativo?\r\nSemplicemente che ci si limita a indicare cosa di desidera, senza curarsi di quelo che accade dietro le quinte.\r\nUn tipico uso dichiarativo di una keyword e\' il controllo d\'accesso, \r\nad esempio in java:\r\n public void mio_metodo(){...\r\n\r\nNoi non sappiamo, ne ci interessa, il meccanismo per cui @mio_metodo()@ diventa privato. Ci limitiamo a dichiararlo tale, e java si occupa dei dettagli.\r\n\r\nIn ruby scriveremmo:\r\n\r\n class C\r\n  def foo\r\n  end\r\n  private :foo\r\n end\r\n\r\nQuesto e\' ancora un metodo \"classico\", altri usi lo rendono ancora piu\' simile ad una keyword:\r\n\r\n\r\n class C\r\n  private\r\n   def privatissimo ... end\r\n  public\r\n   def metodo ... end\r\n  protected\r\n   def protetto ... end\r\n end\r\n\r\n@public@/@private@/@protected@ _sembrano_ delle keyword, ma in realta\' non lo sono affatto!\r\n\r\n\r\nNon dimenticate, infatti, che la dichiarazione di una classe (o di un modulo) in ruby e\' semplicemente un altro pezzetto di codice che viene eseguito come tutto il resto.\r\nInfatti possiamo avere anche questo:\r\n >> class C\r\n >>  puts self\r\n >> end\r\n C\r\n => nil\r\n\r\nDunque, @public@/@private@/@protected@ sono in realta\' dei normali metodi. \r\nMa come funzionano? \r\nBeh, dicono a ruby di trattare ogni definizione di un metodo che li segue in una certa maniera. \r\nA come fanno a sapere quando un metodo viene definito? \r\nFacile, usano @method_added()@\r\n\r\nQuesto metodo viene chiamato ogni volta che viene definito un metodo, e gli viene passato il nome del metodo stesso. Un esempio banale:\r\n >> class Class\r\n >>  def method_added(id)\r\n >>   puts \'aggiunto il metodo %s\' % id\r\n >>  end\r\n >> end\r\n aggiunto il metodo method_added\r\n => nil\r\n\r\nNotate come @method_added()@ sia stato chiamato subito dopo essere stato definito :)\r\nAndando avanti:\r\n >> class C\r\n >>  def foo\r\n >>  end\r\n >> end\r\n aggiunto il metodo foo\r\n => nil\r\nChiaro il concetto?\r\n\r\nA questo punto possiamo provare a definire una pseudo keyword anche noi.\r\n\r\nLa pseudo keyword ci permettera di dichiarare dei metodi come metodi di test (non che la cosa sia molto utile, perche\' il modulo @Test::Unit@ fa gia\' molte piu\' cose e meglio.\r\n\r\nQuello che vogliamo e\' questo:\r\n\r\n class Esempio \r\n    Test \'Test 0. vuoto\'\r\n    def foo\r\n    end\r\n \r\n    def metodo # non un test\r\n    end\r\n \r\n    Test \'Test 1. This test will fail\'\r\n    def this_fail \r\n      assert 10 < 5;\r\n    end\r\n    \r\n    Test \"Test 2. This test will pass\", :this_pass \r\n    def this_pass \r\n      assert 10 > 5\r\n    end\r\n \r\n end\r\n \r\n run_tests(Esempio)\r\n \r\n\r\nE ci aspettiamo un ouput del genere:\r\n\r\n Test 0. vuoto: true\r\n Test 1. This test will fail: false\r\n Test 2. This test will pass: true\r\n \r\n\r\n \r\nAnzitutto definiamo un metodo @assert@  (potremmo anche usare quelle definite in @Test::Unit::Assertion@ ):\r\n\r\n def assert(condition)\r\n  raise \'assertion failed!!\' if not condition\r\n  true\r\n end\r\n\r\nNotate che anche @assert@ e\' una keyword in altri linguaggi :)\r\n\r\nOra definiamo un meccanismo semplice per associare una descrizione ad un metodo:\r\n\r\n def Test(descr)\r\n  @is_test=desc\r\n end\r\n\r\nIn questo modo, quando useremo @Test()@ potremo avere l\'informazione contenente la descrizione disponibile.\r\n\r\n\r\nOra definiamo @method_added()@:\r\n class Class\r\n  def method_added(id)\r\n    UT[id]=desc if @is_test\r\n    @is_test=false\r\n  end\r\n end\r\n\r\nCosa significa quell\'UT ? Semplice, salviamo la descrizione riguardo il metodo in un \r\n@Hash@ globale, nel caso il metodo sia dichiarato come test, poi resettiamo la variabile a false. \r\n\r\nLa nostra \"test suite\" manca ancora di un meccanismo per eseguire i test:\r\n\r\n def run_tests(klass)\r\n    obj=klass.new\r\n    for i in obj.methods.sort\r\n        run_method obj, i\r\n    end\r\n end\r\n\r\n def run_method(obj,name)\r\n    if desc=UT[name]\r\n        retval= obj.send(name) rescue false\r\n        print desc,\": \",retval, \"\\n\"\r\n    end\r\n end\r\n  \r\nFinito! Visto quanto e\' stato semplice? E considerate che questo meccanismo e\' comunque molto potente, ci sono persone che hanno cosruito interi framework su di esso :)\r\n\r\n');
INSERT INTO `revisions` VALUES (139,96,16,'2005-11-25 13:01:16','h1.  Mix-in\r \n\r\nSCRIVIMI!\r\n\r\ninfo:\r\nhttp://c2.com/cgi/wiki?MixIn\n');
INSERT INTO `revisions` VALUES (184,143,16,'2005-11-25 13:01:17','\ndef convert_text(text)\n  text.gsub!(/\\(\\(\\<(.*?)\\>\\)\\)/) { \"[[#$1]]\"}\n  text.gsub!(/^=(.*?)$/) { \"h1. #$1 \"}\n  text.gsub!(/\\(\\(\\{(.*?)\\}\\)\\)/){ \"@#$1@\"}\n  text.gsub!(/\\(\\(\\*(.*?)\\*\\)\\)/){ \"_#$1_\"}\n  text\nend\n\n\nputs convert_text(open(ARGV[0]).read)\n');
INSERT INTO `revisions` VALUES (185,144,16,'2005-11-25 13:01:17','\nDir[\'*.rd\']\n\n');
INSERT INTO `revisions` VALUES (204,165,16,'2005-11-25 13:01:17','h1.  Multiplexer\r \n\r\nCosa e\' un Multiplexer?\r\nun multiplexer e\' un oggetto che funziona _moltiplicando_ un messaggio, e inviandolo \r\na degli oggetti registrati presso di lui.\r\nL\'utilita\' di un simile oggetto e\' evidente, ad esempio nel caso si desideri effettuare il log in un file di tutto cio\' che viene stampato a schermo, ma continuando a poter leggere anche i messaggi in tempo reale, si potrebbe usare un Multiplexer che nasconda @STDOUT@ \r\ne un oggetto @File@. Questa e\' esattamente la funzione del comando @tee@ di UNIX.\r\n\r\nIn ruby, l\'implementazione e\' semplicissima:\r\n\r\n class Multiplexer\r\n  def initialize(*oggetti)\r\n   @ogg=oggetti\r\n  end\r\n  def method_missing(metodo,*args,&blk)\r\n   @ogg.each { |o| o.send(metodo,*args,&blk) }\r\n  end\r\n end\r\n\r\n\r\nCosa accade qui? Beh, un oggetto @Multiplexer@ viene inizializzato passsandogli un array di elementi.\r\nUn @Multiplexer@ non risponde a nessun metodo in particolare. \r\nOgni volta che su di un tale oggetto viene chiamato un metodo a cui lui non sa come rispondere, viene richiamato @method_missing@. A questo metodo vengono passati:\r\n (1) un simbolo che rappresenta il metodo chiamato (ad esempio @puts()@ )\r\n (2) un array contenente tutti i parametri passati al metodo \r\n (3) un eventuale blocco\r\n\r\nNoi non faremo altro che inviare questi messaggi ad ogni oggetto, con una semplice iterazione. \r\nVediamo un esempio:\r\n\r\n >> require \'multiplexer\'\r\n => true\r\n >> require \'stringio\'\r\n => true\r\n >> f1,f2 = StringIO.new, StringIO.new\r\n => [#<StringIO:0x27e17a0>, #<StringIO:0x27e1650>]\r\n >> m=Multiplexer.new(f1,f2)\r\n => #<Multiplexer:0x27d9868 @ogg=[#<StringIO:0x27e17a0>, #<StringIO:0x27e1650>]>\r\n >> m.puts \'ciao!\'\r\n => [#<StringIO:0x27e17a0>, #<StringIO:0x27e1650>]\r\n >> f1.string\r\n => \"ciao!\\n\"\r\n >> f2.string\r\n => \"ciao!\\n\"\r\n => nil\r\n\r\nil file multiplexer.rb ovviamente contiene il nostro codice. \r\n@StringIO@ rappresenta un ottimo modo per fare delle prove con un testo senza scriverlo. Infatti si tratta di una stringa che si comporta com un @File@ (beh, come un @IO@ per essere precisi :) \r\n\r\nNotate pero\' una cosa: se gli oggetti non sono coerenti, questo sistema crolla:\r\n >> str,ary= \'ciao\', [1]\r\n => [\"ciao\", [1]]\r\n >> m=Multiplexer.new(str,ary)\r\n => #<Multiplexer:0x27c57f8 @ogg=[\"ciao\", [1]]>\r\n >> m << \'accodiamo\'  # tutti e due gli oggetti rispondono a \'<<\'\r\n => [\"ciaoaccodiamo\", [1, \"accodiamo\"]]\r\n >> str\r\n => \"ciaoaccodiamo\"\r\n >> ary\r\n => [1, \"accodiamo\"]\r\n >> m.upcase!   # un array non sa come diventare maiuscolo!\r\n NoMethodError: undefined method `upcase\' for [1, \"accodiamo\"]:Array\r\n        from ./multiplexer.rb:6:in `send\'\r\n        from ./multiplexer.rb:6:in `method_missing\'\r\n        from ./multiplexer.rb:6:in `each\'\r\n        from ./multiplexer.rb:6:in `method_missing\'\r\n        from (irb):16\r\n\r\nPossiamo cambiare la definizione del nostro metodo per far si che funzioni nonostante gli errori, usando lo _statement modifier_ per @rescue@.\r\nUno _statement modifier_ serve a cambiare il comportamento di un istruzione in certi casi. Ad esempio:\r\n print x if x == \'ciao\'\r\n\r\nNel caso di @rescue@ esso dipende dalla generazione di un eccezione. Basta quindi ridefinire @method_missing()@ cosi\':\r\n\r\n def method_missing(met,*arg,&blk)\r\n   @ogg.each do |o|\r\n    o.send(met,*arg,&blk) rescue nil\r\n   end\r\n  end\r\n\r\nche significa : ad ogni elemento di @@ogg @ inviamo il messaggio @met@ con i suoi parametri, se accade un errore recuperiamolo, e non facciamo nulla. Esempio:\r\n\r\n >> m=Multiplexer.new(\'ciao\',[])\r\n => #<Multiplexer:0x2751ea8 @ogg=[\"ciao\", []]>\r\n >> m.capitalize!\r\n => [\"Ciao\", []]\n');
INSERT INTO `revisions` VALUES (205,166,16,'2005-11-25 13:01:17','h1.  NubyQuiz Giugno 2003\r \n\r\nL\'idea di questo mese e\' la realizazione di un semplice sostituto per l\'utility _wget_.\r\nIn sostanza , lo script deve accettare da riga di comando un indirizzo \r\ncon questi possibili formati :\r\n * http://blkalla.boh/burp.rbx\r\n * ftp://blanbla.baz/pkg.zip\r\n * ftp.bau.org/file.tgz\r\n * www.miao.org/page.html\r\n\r\ned effettuare il recupero del file salvandolo su file system.\r\nOvviamente per gli indirizzi stile ftp verra\' usata la porta 21 e la 80 per quelli web.\r\n\r\n\r\n \r\n\r\nh1. == possibili estensioni: \r \nuna flag \'--port\' per indicare una porta specifica\r\n\r\noppure\r\n\r\nuna flag \'--mirror\' che funzionerebbe cosi\':\r\n *recupero di tutti i file da una directory ftp\r\n *recupero di tutti i file collegati ad una pagina web (come parsare l\'html?)\n');
INSERT INTO `revisions` VALUES (206,167,16,'2005-11-25 13:01:17','h1.  NumeriComplessi\r \n\r\n_perl cb 2.14_\r\n\r\nPuo\' capitare di fare calcoli avanzati in ruby, e ruby ofre un ampio supporto a numeri di dimensioni arbitrarie, decimali, razionali, complessi etc etc.. \r\nSupponendo che dobbiate manipolare numeri complessi, basta caricare la libreria apposita, inclusa nella libreria standard, ed istanziarli:\r\n\r\n >> require \'complex\'\r\n => true\r\n >> a=Complex.new 10, 20\r\n => Complex(10, 20)\r\n >> a+ 15\r\n => Complex(25, 20)\r\n >> 10+a\r\n => Complex(20, 20)\r\n\r\npossiamo usre anche la notazione polare:\r\n\r\n >> Complex.polar 100, 45 #raggio, gradi\r\n => Complex(52.532198881773, 85.0903524534118)\r\n\r\nCome vedete e\' semplicissimo, e grazie alle potenzialita\' di ruby, anche i metodi gia\' esistenti possono gestire numeri complessi, senza intaccare il funzionamento di base:\r\n\r\n >> Math.sqrt 10\r\n => 3.16227766016838\r\n >> require \'complex\'\r\n => true\r\n >> Math.sqrt( Complex.new(1,2))\r\n => Complex(1.27201964951407, 0.786151377757423)\r\n >> Math.sqrt 10\r\n => 3.16227766016838\r\n\r\n\r\n\r\n');
INSERT INTO `revisions` VALUES (207,168,16,'2005-11-25 13:01:17','h1.  OggettiProcEMethod\r \n\r\n@Proc@ e metodi sono entrambi oggetti in ruby. Le @Proc@ rappresentano, come prima cosa, delle funzioni anonime, cioe\' che possono essere definite senza un nome particolare. Si fa uso di \r\n@Proc@ tutte le volte che si passa un blocco in input ad una funzione come ad esempio @each@.\r\n\r\nLa creazione di una @Proc@ puo\' avvenire in tre modi:\r\n # primo metodo                  \r\n prc=Proc.new do |arg|\r\n      ...codice..\r\n     end\r\n\r\n # secondo metodo\r\n prc=proc do |arg|\r\n      ...codice..\r\n     end\r\n\r\n # terzo metodo\r\n prc=lambda do |arg|\r\n      ...codice..\r\n     end\r\n\r\n@lambda &blk@ e @proc &blk@ sono effettivamente sinonimi, mentre la creazione di un oggetto @Proc@ con @Proc.new@ ha una differenza sottile. \r\nLa differenza e\' nel passaggio dei parametri:\r\n\r\n >> p=Proc.new {|a,b| puts a,b }\r\n => #<Proc:0x401f9570@(irb):1>\r\n >> f=lambda {|a,b| puts a,b }\r\n => #<Proc:0x401f61b8@(irb):2>\r\n >> p.call 1,2\r\n 1\r\n 2\r\n => nil\r\n >> f.call 1,2\r\n 1\r\n 2\r\n => nil\r\n >> p.call 1\r\n 1\r\n nil\r\n => nil\r\n >> f.call 1\r\n ArgumentError: wrong number of arguments (1 for 2)\r\n         from (irb):2\r\n         from (irb):2:in `call\'\r\n         from (irb):6\r\n\r\n\r\nCioe\' @proc@ e @lambda@ si comportano come i normali metodi, richiedendo un numero esatto di parametri, mentre l\'altra forma e\' piu\' _elastica_ :-).\r\n\r\nPer chi si chiedesse cosa cavolo e\' lambda: si tratta del nome  che viene dato alle funzioni anonime in altri linguaggi, come ad esempio @LISP@.\r\n\r\n\r\nCome potete intuire dall\'esempio, un oggetto @Proc@ per essere applicato a dei parametri richiede l\'uso del metodo @call()@. Dunque, non scriveremo \r\n p= lambda {|z| print z }\r\n p(10) # sintassi come in python o scheme\r\n\r\nScriveremo invece\r\n p= lambda {|z| print z }\r\n p.call(10) # simile a funcall in Common LISP\r\n\r\nLa prima sintassi potra\' sembrare piu\' conveniente, ma in ruby e\' impossibile, visto che le parentesi sono opzionali. Come si farebbe a capire se @print@ deve essere usata come funzione o si deve usare il suo valore di ritorno?\r\n\r\nQuantomeno, ruby ci permette di \"imitare\" la sintassi classica, usando delle parentesi quadre:\r\n p= lambda {|z| print z }\r\n p[10] # equivalente a p.call(10)\r\n\r\n\r\nUn oggetto di tipo metodo invece viene creato cosi\':\r\n\r\n met=method(:nomemetodo)\r\n\r\noppure\r\n\r\n met=oggetto.method(:nomemetodo)\r\n\r\nUna volta creati, questi oggeti funzionano praticamente in maniera identica:\r\n\r\n def fun(a)\r\n  a**2\r\n end\r\n nil\r\n oggetto=method :fun # #<Method: Object#fun>\r\n oggetto.call(10) # 100\r\n oggetto[10] # uguale a call()\r\n\r\n\r\nUn ultima cosa: le funzioni che accettano in input un blocco si lamenteranno se provate a passargli un oggetto @Proc@; o @Method@. Per espandere questi oggetti/funzione in blocchi vi bastera\'\r\nmettere davanti al nome della variabile il simbolo \"&\"\r\n\r\n');
INSERT INTO `revisions` VALUES (208,169,16,'2005-11-25 13:01:18','h1.  OnLispOnRuby\r \n\r\nRuby e\' stato spesso descritto come \"un lisp con sintassi infissa\". \r\nQuesto ha un senso in qualche modo, considerato che ruby fa un uso molto ampio di FormaLambda,\r\nche qualche funzione ha nomi simili (map, tanto per dire) e che alcune cose matz dice di averle prese dal CLOS.\r\n\r\nMa effettivamente, le similarita\' non sono tanto se si guarda meglio.\r\nEppure, guardando meglio ancora, si trova una similarita\' anche piu\' profonda, cioe\'; l\'attenzione ad una tecnica di progrmmazione definita \"bottom up\" in cui le cose complesse vengono costruite su quelle semplici.\r\n\r\nA questo riguardo, e\' obbligatorio pensare al libro OnLisp di Paul Graham, che e\' un po\' la massima espressione di questa idea. \r\n\r\nOvviamente il libro parla moltissimo di macro.. eppure per qualche motivo sento che alcune cose possono essere tradotte. \r\nDunque, basandosi su [[questo codice|URL:http://lib1.store.vip.sc5.yahoo.com/lib/paulgraham/onlisp.lisp]], io ci provo :)\r\n\r\n(nota: scrivo senza possibilita\' di verificare il codice al momento, lo faro\' poi, senno fatelo voi :) \r\n\r\nSarebbe giusto implementare anche tutte le funzioni piu\' piccole, ma molte di esse sono built-in in ruby, e noi vogliamo sbrigarci ad arrivare a quelle piu\' interessanti :) \r\n\r\nOk, facile:\r\n (defun last1 (lst)\r\n  (car (last lst)))\r\n\r\nE\' una funzone predefinita:\r\n  lst.last\r\n\r\n\r\nquesta:\r\n (defun single (lst)\r\n   (and (consp lst) (not (cdr lst))))\r\n\r\nsarebbe\r\n def single? (lst)\r\n    lst[0] and not lst[1]\r\n end\r\nma in ruby sarebbe meglio:\r\n class Array\r\n   def single?\r\n     size==1\r\n   end\r\n end\r\n\r\nh1. == Attenzione Array del Ruby != cons del Lisp  -- Matley\r \n\r\nAnche in Lisp potresti fare\r\n (defmethod single? ((a list))\r\n  (eq (size a) 1))\r\n   \r\nappend1/conc1 sono un poco inutili, data la presenza degli array literal.\r\nmklist e\' anch\'essa un builtin, la funzione @Kernel::Array(arg)@.\r\n\r\nLa funzione \"longer\" e\' piu\' interessante:\r\n\r\n (defun longer (x y)\r\n   (labels ((compare (x y)\r\n              (and (consp x) \r\n                   (or (null y)\r\n                       (compare (cdr x) (cdr y))))))\r\n     (if (and (listp x) (listp y))\r\n         (compare x y)\r\n         (> (length x) (length y)))))\r\n\r\ntradotto passo passo sarebbe un casino, ma in sostanza:\r\n def longer (x,y)\r\n    x.is_a?(Array) and y.is_a?(Array) and (x.size > y.size)\r\n end\r\n\r\nNon sono la stessa cosa, la longer di graham funziona con tutti gli oggetti che supportano l\'operazione length, la tua solo con array. -- Matley\r\n\r\nLa funzione filter &#232; un builtin, dentro Enumerable.\r\n\r\n\r\nPer le funzioni te la caveresti bene piu` o meno, ma per le macro? come fai a rendere una cosa del tipo\r\n (defmacro aif (test-form then-form &optional else-form)\r\n  `(let ((it ,test-form))\r\n     (if it ,then-form ,else-form))) \r\n\r\nCon cui puoi scrivere cose come:\r\n (aif (doesnt-work? object)\r\n    (drop it)\r\n   (use it))\n');
INSERT INTO `revisions` VALUES (210,171,16,'2005-11-25 13:01:18','h1.  OrdinareUnFile\r \n\r\nOrdinare un file e\' un operazione banale, e di norma non avremo bisogno di usare ruby \r\nper farlo, visto che i sono gia\' piccoli programmini che lo fanno (il classico sort di \r\nunix, ad esempio). \r\nEppure e\' utile vedere come farlo con ruby, per aiutare a capire come manipolare i file \r\ne come usare i metodi di ordinamento degli oggetti @Enumerable@\r\n\r\nIl metodo piu\' classico e\' questo:\r\n\r\n file=File.new(\'tmp.txt\') \r\n linee=file.readlines\r\n file.close\r\n linee.sort!\r\n file2 = File.new(\'tmp2.txt\',\'w+\')\r\n for linea in linee\r\n  file2.write(linea)\r\n end\r\n file2.close\r\n\r\n\r\nChe tradotto significa:\r\n (1) apri il file tmp.txt\r\n (2) metti tutte le linee del file in un array, di nome @linee@\r\n (3) chiudi il file tmp.txt che non serve piu\'\r\n (4) ordina l\'array _in place_ cioe\' senza crearne un altro\r\n (5) apri un nuovo file\r\n (6) per ogni elemento dell\'array, scrivilo nel file tmp2.txt\r\n (7) chiudi tmp2.txt\r\n\r\nQuesta soluzione e\' semplice, ma un po\' incompleta e un po\' troppo lunga.\r\n\r\nSemplifichiamo. Anzitutto possiamo usare @open()@ invece che File.new, il \r\nrisultato non cambiera\':\r\n\r\n  file=open(\'tmp.txt\') \r\n\r\npoi, potremmo spostare l\'operazione di @sort@ nello stesso punto linea in cui \r\nleggiamo le linee:\r\n\r\n linee=file.readlines.sort!\r\n\r\ned in effetti, non abbiamo bisogno di @sort!@. Infatti questo metodo serve a modificare\r\nun array _in place_ cioe\' senza crearne un altro. Ma a noi l\'array non ordinato \r\nnon serve, ci basta assegnare a @linee@ direttamente quello ordinato:\r\n\r\n linee=file.readlines.sort\r\n\r\nIl codice dunque, a questo punto sara\' cosi\' :\r\n \r\n file=open(\'tmp.txt\') \r\n linee=file.readlines.sort\r\n file.close\r\n file2 = open(\'tmp2.txt\',\'w+\')\r\n for linea in linee\r\n  file2.write(linea)\r\n end\r\n file2.close\r\n\r\n\r\nma quel @for...@ occupa addirittura tre linee, troppa roba.\r\nA questo punto ci torna utile [[ri]]. infatti, guardate qui:\r\n\r\n ri IO.puts\r\n ---------------------------------------------------------------- IO#puts\r\n     ios.puts( [anObject]* ) -> nil\r\n ------------------------------------------------------------------------\r\n     Writes the given objects to ios as with IO#print. Writes a record\r\n     separator (typically a newline) after any that do not already end\r\n     with a newline sequence. If called with an array argument, writes\r\n     each element on a new line. \r\n\r\nNotate il dettaglio? Esatto, non ci serve a niente iterare, ci bastera\' passare l\'array a @puts@ per vedercelo stampare tutto, un elemento per ogni linea.\r\n\r\n\r\nDunque possiamo scrivere:\r\n \r\n file=open(\'tmp.txt\') \r\n linee=file.readlines.sort\r\n file.close\r\n file2 = open(\'tmp2.txt\',\'w+\')\r\n file2.puts(linee)\r\n file2.close \r\n\r\n\r\nMh.. si, va gia\' molto meglio. Ma ora notate un altra cosa carina: \r\nun oggetto di tipo @File@ include il modulo @Enumerable@.\r\nQuesto significa che possiamo usare @sort()@ direttamente su quell\'oggetto,\r\nsenza leggere l\'array con @readlines@. Inoltre, in realta\' non \r\nabbiamo bisogno di usare @file@ e @file2@:\r\n\r\n linee=open(\'tmp.txt\').sort \r\n\r\n open(\'tmp2.txt\',\'w+\').puts(linee)\r\n\r\n\r\nEh si, avete ragione, anche @linee@ non serve a niente:\r\n open(\'tmp.txt\',\'w+\').puts open(\'tmp.txt\').sort\r\n\r\n\r\nIn effetti, cmq, questa soluzione e\' scorretta. Manca una gestione sensata degli errori.\r\n\r\nGestire gli errori e\' importante. Un metodo classico per farlo e\' racchiudere  il codice \r\nin un blocco @begin..end@:\r\n begin\r\n  file=open(\'tmp.txt\') \r\n  linee=file.readlines.sort\r\n  file2 = open(\'tmp2.txt\',\'w+\')\r\n  file2.puts(linee)\r\n rescue\r\n  puts \"avvenuta eccezione!!\"\r\n ensure\r\n  file.close\r\n  file2.close\r\n end\r\n\r\nCome vedete, in questo esempio ci preoccupiamo di chiudere i file in ogni caso, e \r\ndi comunicare evantuali errori all\'utente.\r\nAvremmo potuto anche racchiudere il tutto in un metodo:\r\n\r\n def ordina(filein,fileout)\r\n  file=open(filein) \r\n  linee=file.readlines.sort\r\n  file2 = open(fileout,\'w+\')\r\n  file2.puts(linee)\r\n rescue\r\n  puts \"avvenuta eccezione!!\"\r\n ensure\r\n  file.close\r\n  file2.close\r\n end\r\n\r\nnotate come non ci sia bisogno di definire un blocco @begin..end@, in quanto ruby\r\ncapisce da solo che il blocco che ci interessa e\' quello del @def..end@.\r\n\r\nMa se vogliamo davvero una soluzione ottimale, faremo cosi\':\r\n\r\n open(\'tmp2.txt\',\'w+\') do |fd|\r\n  fd.puts open(\'tmp.txt\').sort\r\n end\r\n\r\nIn questa ultima soluzione gli errori vengono gestiti direttamente da @open()@,\r\nnon lasciamo nessun descrittore di file aperto. Infatti sara\' la open stessa, alla fine del blocco, a preoccuparsi di richiamare il @GC@ e ripulire tutto.\r\nProvate a farlo con un altro linguaggio in maniera altrattanto pulita e chiara :)\r\n');
INSERT INTO `revisions` VALUES (211,172,16,'2005-11-25 13:01:18','h1.  orphan\r \n');
INSERT INTO `revisions` VALUES (212,173,16,'2005-11-25 13:01:18','h1.  OttenereRuby\r \n\r\nIl sito di sviluppo principale di ruby e\' [[ruby-lang.org|URL:http://www.ruby-lang.org]]\r\npotete scaricare i sorgenti da cvs seguendo le istruzioni riportate in quelle pagine, o usare cvsweb, o l\'ftp da [[ftp.ruby-lang.org|URL:ftp://ftp.ruby-lang.org]].\r\n\r\nAd ogni modo, se usate una distribuzione linux o un *bsd prpbabilmente esiste gia\' un pacchetto per la vostra distribuzione.\r\n\r\nSe usate windows potete scaricare un pacchetto installativo che contiene anche alcuni moduli aggiuntivi (Tcl/Tk, FOX, OpenGL), da [[qui|URL:http://rubyinstaller.rubyforge.org/wiki/wiki.pl]].\n');
INSERT INTO `revisions` VALUES (213,175,16,'2005-11-25 13:01:18','prova di nuova pagina\r\n\r\n\r\n\r\n\r\nh1. == titolo ? \n');
INSERT INTO `revisions` VALUES (216,180,16,'2005-11-25 13:01:18','h1. \r \n\r\n');
INSERT INTO `revisions` VALUES (218,182,16,'2005-11-25 13:01:18','h1.  Persone\r \nUn file di dati di xearth contenente la locazioni dei vari utenti di Ruby italiani.\r\nXearth e\' il ben conosciuto programma per X11 che mostra un immagine della terra correttamente illuminata dalla posizione corrente del Sole. Vedi anche xplanet\r\n\r\nwget -qO - \"http://ada2.unipv.it/ruby/index.cgi?cmd=src;name=Persone\" | sed \'s/<[^<]*>//g\' | grep \'^[0-9]\' > foo && xearth -markerfile foo -mag 10 -pos \"fixed 42 13\"\r\n\r\nPer trovare la tua posizione usa www.multimap.com, cliccate sulla mappa finche\' non avete raggiunto la definizione voluta e poi copiate longitudine e latitudine dal box sottostante (map information)\r\n\r\n45.0518 9.698 matley # [[Luigi Panzeri]]\r\n\r\n39.2276 9.1176 gcorriga # [[Giovanni Corriga]]\r\n\r\n41.9909 12.0886 riffraff # [[Gabriele Renzi]]\r\n\r\n45.7887 12.0476 kki # [[Stefano Zamprogno]]\r\n\r\n43.6015 13.5099 Oberon\r\n\r\n39.0366 16.8434 StelK\r\n\r\n40.9076 14.7792 kirash # [[Gianluigi Spagnuolo]]\r\n\r\n44.4953  9.7675 abelli # [[Andrea Abelli]]\r\n\r\n45.722   9.445 TheBox # [[Piergiuliano Bossi]]\r\n\r\n39.2397  9.1321 rcamplan # [[Romolo Camplani]]\n');
INSERT INTO `revisions` VALUES (219,183,16,'2005-11-25 13:01:18','h1.  Piergiuliano Bossi\r \n\r\n');
INSERT INTO `revisions` VALUES (220,184,16,'2005-11-25 13:01:18','h1.  Progetti\r \n\r\n[[Collaborazione_siforge]]\r\n\r\n[[Stato delle Traduzioni]]\r\n\r\n[[wxruby su windows]]\r\n\r\n[[Nuovo dominio]]\n');
INSERT INTO `revisions` VALUES (221,185,16,'2005-11-25 13:01:18','h1.  Programming Ruby\r \n\r\n\r\nh1. =Info\r \n\r\nProgramming Ruby - The Pragmatic Programmer\'s Guide\r\n_di David Thomas e Andrew Hunt_\r\n\r\nLa versione originale si trova all\'indirizzo [[URL:http://www.rubycentral.com/book/]]\r\n\r\nPer collaborare, sia come traduttore sia come revisore, rivolgetevi ad un\r\nmembro del gruppo.\r\n\r\n\r\nh1. =Stato Traduzione\r \n\r\n(1) Foreword _tradotto da:_ Massimo Arnaudo\r\n(2) Preface  _tradotto da:_ Massimo Arnaudo\r\n(3) Roadmap  _tradotto da:_ Massimo Arnaudo\r\n(4) Ruby.new _tradotto da:_ Massimo Arnaudo\r\n(5) Classes, Objects, and Variables  _tradotto da:_ Massimo Arnaudo\r\n(6) Containers, Blocks, and Iterators  _tradotto da:_ Massimo Arnaudo\r\n(7) Standard Types  _tradotto da:_ Massimo Arnaudo\r\n(8) More About Methods  _tradotto da:_ Massimo Arnaudo\r\n(9) Expressions  _tradotto da:_ Massimo Arnaudo\r\n(10) Exceptions, Catch, and Throw  _tradotto da:_ Massimo Arnaudo\r\n(11) Modules  _tradotto da:_ Massimo Arnaudo\r\n(12) Basic Input and Output  _tradotto da:_ Massimo Arnaudo\r\n(13) Threads and Processes  _tradotto da:_ Massimo Arnaudo\r\n(14) When Trouble Strikes  _tradotto da:_ Massimo Arnaudo\r\n(15) Ruby and Its World  _tradotto da:_ Panther\r\n(16) Ruby and the Web _in traduzione_\r\n(17) Ruby Tk\r\n(18) Ruby and Microsoft Windows\r\n(19) Extending Ruby\r\n(20) The Ruby Language\r\n(21) Classes and Objects\r\n(22) Locking Ruby in the Safe\r\n(23) Reflection, ObjectSpace, and Distributed Ruby\r\n(24) Built-in Classes and Methods\r\n(25) Standard Library\r\n(26) Object-Oriented Design Libraries\r\n(27) Network and Web Libraries\r\n(28) Microsoft Windows Support\r\n(29) Embedded Documentation\r\n(30) Interactive Ruby Shell\r\n(31) Support\r\n\r\n\r\n[[Stato delle Traduzioni]]\r\n\r\n');
INSERT INTO `revisions` VALUES (222,186,16,'2005-11-25 13:01:18','h1.  Prova \r \n\r\nh1. = Paragrafo\r \n\r\nbla bla\r\nSi va a capo con un semplice \"invio\".\r\n\r\nh1. == Sotto Paragrafo\r \n\r\nbla bla bla\r\n+ Sotto Sotto Pragrafo\r\n\r\nancora bla \r\n\r\n++ Sotto Sotto Sotto Paragrafo\r\n\r\n+++ E quanti livelli volete?!\r\n\r\n++++ \"quattro almeno :)\"\r\n\r\n_qualcosa in corsivo_\r\n\r\nEsempio di codice:\r\n\r\n@puts \"Ciao a Tutti\"@\r\n\r\n\r\n\r\n\r\nscriviamo un link:\r\n[[questo e\' un link all\'indice|top]]\r\ninvece, [[questo|URL:http://www.ruby-lang.org/]] e\' un link alla homepage di ruby.\r\n\r\nNon vogliamo che la linea seguente venga interpretata:\r\n [[posso scrivere quello che mi pare!]]\r\n\r\n\r\nE adesso un bell\'elenco:\r\n * 1\r\n * 2\r\n    * 2.1\r\n    * 2.2\r\n       * 2.2.1\r\n * tre\r\n\r\nO un elenco numerato:\r\n(1) il primo \r\n(2) il secondo\r\n\r\n[[pagina]]\r\n((-nota a fin di pagina, il numero lo mette da solo-))\n');
INSERT INTO `revisions` VALUES (223,187,16,'2005-11-25 13:01:18','h1.  questa \nprova\n\n d-a ae -:? questa in w3m \n***** questa con links.\nw3m dovrbebe essere utf-aware, mentre links no.\n');
INSERT INTO `revisions` VALUES (224,188,16,'2005-11-25 13:01:18','h1.  Quiz Agosto 2004\r \n\r\nDato un\'Array di oggetti ordinati, scrivere una funzione (o in alternativa una classe OrderedArray) che inserisca un nuovo oggetto nella posizione corretta.\r\n\r\n\r\n\r\nLa complessita\' deve essere logaritmica.\r\n\r\nEs.\r\n\r\n[3, 6, 34, 89, 112].insert_sorted 20\r\n->\r\n[3, 6, 20, 34, 89, 112]\r\n\r\n');
INSERT INTO `revisions` VALUES (225,189,16,'2005-11-25 13:01:18','h1.  Quiz Aprile 2003\r \n\r\nTratto da \"On Lisp\" di Paul Graham:\r\n\r\nScrivere una funzione \'memoize\' che prende come argomento una funzione e ritorna una funzione \"memoizzata\", cioe\' una funzione che chiamata memorizza l\'associazione del suo input con l\'output in modo da non doverlo ricalcolarlo le volte successive. Es.\r\n\r\n def slowid(x)\r\n  sleep 5\r\n  x\r\n end\r\n\r\n memoized_slowid = memoize(slowid)\r\n\r\n memoized_slowid 3\r\n > 3              ...(in 5 secondi)\r\n\r\n memoized_slowid 3\r\n > 3              ...(istantaneamente)\r\n\r\n memoized_slowid 7\r\n > 7              ...(in 5 secondi)\r\n\r\n memoized_slowid 7\r\n > 7              ...(istantaneamente)\r\n\r\ne cosi\' via\r\n\r\nSoluzioni:\r\n    *[[Soluzione Aprile 2003 di Luigi Panzeri]]\r\n    *[[Soluzione Aprile 2003 di Gabriele Renzi]]\r\n');
INSERT INTO `revisions` VALUES (226,190,16,'2005-11-25 13:01:18','h1.  Quiz Febbraio 2003 \n\nTratto dal Perl Quiz of the Week dello stesso periodo\n\nCostruire una funzione, \'histogram()\', i cui argomenti saranno una lista di  numberi.  La funzione dovrebbe costruire un diagramma a barre e \nrestituire una lista di stringhe che, se stampate, visualizzerebbero i numberi nella maniera adatta.\n');
INSERT INTO `revisions` VALUES (227,191,16,'2005-11-25 13:01:18','h1.  Quiz Giugno 2003\r \n\r\nL\'idea di questo mese e\' la realizazione di un semplice sostituto per l\'utility _wget_.\r\nIn sostanza , lo script deve accettare da riga di comando un indirizzo \r\ncon questi possibili formati :\r\n * http://blkalla.boh/burp.rbx\r\n * ftp://blanbla.baz/pkg.zip\r\n * ftp.bau.org/file.tgz\r\n * www.miao.org/page.html\r\n\r\ned effettuare il recupero del file salvandolo su file system.\r\nOvviamente per gli indirizzi stile ftp verra\' usata la porta 21 e la 80 per quelli web.\r\n\r\n\r\n \r\n\r\nh1. == possibili estensioni: \r \nuna flag \'--port\' per indicare una porta specifica\r\n\r\noppure\r\n\r\nuna flag \'--mirror\' che funzionerebbe cosi\':\r\n *recupero di tutti i file da una directory ftp\r\n *recupero di tutti i file collegati ad una pagina web (come parsare l\'html?)\n');
INSERT INTO `revisions` VALUES (228,192,16,'2005-11-25 13:01:18','h1.  Quiz Maggio 2003\r \nscrivere un metodo  @synchronize(unMetodo)@ \r\nche provveda a creare al posto nostro un sistema per \r\nl\'accesso concorrente ad un metodo, sul modello della keyword\r\n\'synchronized\' in java.\r\n \r\nIn sostanza deve essere possibile fare una cosa del genere\r\n \r\n  def metodo\r\n   ..\r\n  end\r\n  \r\n  synchronize (:metodo) \r\n  # o synchronize(methodObject)\r\n  \r\n  (1..10).each {\r\n   Thread.new { chiamata a metodo}\r\n  }\r\n  \r\n\r\ninsomma, i thread non devono preoccuparsi di attivare/rilasciare lock nell\'accedere al metodo.\r\n  \r\nMa non finisce qui :) \r\nMaggior gloria a un\'ulteriore versione di @synchronize@:\r\n  \r\n   synchronize(unaClasse)\r\n  \r\nche restituisca una classe con tutti i metodi sincronizzati, \r\n(possibilmente anche i metodi d\'istanza). \r\nAd esempio:\r\n SyncArray=synchronize(Array)\r\n\r\n\r\n\r\nSyncArray\r\n\r\n\r\n');
INSERT INTO `revisions` VALUES (229,193,16,'2005-11-25 13:01:18','h1.  Quiz Marzo 2003\r \n\r\nScrivere una funzione, @format_number_list@, che prende come argomento\r\nuna lista di interi, e restituisce una stringa che rappresenta la lista in forma\r\ncompatta e leggibile.\r\n\r\nAd esempio,\r\n format_number_list(1, 2, 4, 5, 6, 7, 9, 13, 24, 25, 26, 27)\r\nrestituira\'\r\n \"1-2, 4-7, 9, 13, 24-27\"\r\n\r\nScrivere anche una funzione, @expand_number_list@, che fa esattamente il\r\ncontrario\r\n expand_number_list(\"1-2, 4-7, 9, 13, 24-27\")\r\nrestituira\'\r\n (1, 2, 4, 5, 6, 7, 9, 13, 24, 25, 26, 27)\r\n\r\n\r\n[[RubyQuiz del mese]]\n');
INSERT INTO `revisions` VALUES (230,194,16,'2005-11-25 13:01:18','h1.  Quiz Ottobre 2004\r \n\r\nCreare una classe che implementi un intervallo\r\nridimensionabile e con possibili \"buchi\".\r\n\r\nUn esempio di API:\r\n\r\n >>a=Klasse.new 1..10\r\n =><Klasse 1..10>\r\n >>a.delete 5\r\n =><Klasse 1..4,6..10>\r\n >>a.delete 8\r\n =><Klasse 1..4,6..7,9..10>\r\n >>a.add 15\r\n =><Klasse 1..4,6..7,9..10,15>\r\n >>a.min= 7\r\n =><Klasse 7,9..10,15>\r\n >>a.max= 9\r\n =><Klasse 7,9>\r\n\r\nLa struttura dovrebbe poi rispondere ad @each()@ in modo che ci\r\npossa infilare dentro @Enumerable@.\r\n\r\nUsa un cavolo di Array, direte voi. Vero, ma la parte\r\ninteressante e\' relativa all\'uso di margini come\r\nInfinity e -Infinity, per i quali non e\' possibile pensare di\r\ncostruire un Array.\r\n\r\nCancellami\n');
INSERT INTO `revisions` VALUES (231,195,16,'2005-11-25 13:01:18','h1.  RDoc\r \n');
INSERT INTO `revisions` VALUES (232,196,16,'2005-11-25 13:01:18','h1.  recent \n');
INSERT INTO `revisions` VALUES (233,197,16,'2005-11-25 13:01:18','h1.  Reflection\r \n\r\nLa reflection, o _introspezione_, e\' la caratteristica di alcuni linguaggi di rendere disponibili al codice informazioni su se stesso. \r\nDetta cosi\' puo\' sembrare difficile, ma e\' molto semplice:\r\n\r\n >> puts 5.class\r\n Fixnum\r\n\r\nCome vedete, e\' possibile effettuare una _introspezione_ dell\'oggetto @5@, chiedendogli quale sia la sua classe. avremmo anche potuto chiedergli quale e\' \r\nla sua superclasse: \r\n >> 5.class.superclass\r\n >> Integer\r\n >> 5.class.superclass.superclass\r\n => Numeric\r\n >> 5.class.superclass.superclass.superclass\r\n => Object\r\n\r\nOppure sapere quali siano i suoi metodi:\r\n >> puts 5.methods.sort\r\n %\r\n &\r\n *\r\n **\r\n +\r\n ...e cosi\' via\r\nla lista e\' piuttosto lunga. Come potremmo fare per ridurla ?, Beh, alcuni metodi di reflection sono piu\' specifici. Infatti, abbiamo a disposizione:\r\n * protected_methods\r\n * instance_methods\r\n * public_instance_methods\r\n * private_methods\r\n * public_methods\r\n * protected_instance_methods\r\n * methods\r\n * private_instance_methods\r\n * singleton_methods\r\n\r\nOvviamente alcuni di questi metodi sono disponibili solo per Classi e non per oggetti qualunque (si tratta di quelli in cui e\' presente la parola _instance_).\r\n\r\nIn piu\', questi metodi accettano un parametro opzionale, se e\' @false@ verrannpo esclusi dall\'elenco i metodi non definiti nella clase attuale. Anche questo sembra difficile ma non lo e\':\r\n\r\n >> class C\r\n >>  def met\r\n >>  end\r\n >> end\r\n => nil\r\n >> C.new.public_methods\r\n => [\"dup\", \"hash\", \"private_methods\", \"nil?\", \"tainted?\", \"class\", \"singleton_me\r\n thods\", \"=~\", \"__send__\", \"untaint\", \"instance_eval\", \"extend\", \"kind_of?\", \"obj\r\n ect_id\", \"instance_variable_get\", \"inspect\", \"frozen?\", \"taint\", \"id\", \"public_m\r\n ethods\", \"respond_to?\", \"equal?\", \"to_a\", \"clone\", \"method\", \"protected_methods\"\r\n , \"freeze\", \"instance_variable_set\", \"type\", \"is_a?\", \"methods\", \"==\", \"send\", \"\r\n met\", \"instance_of?\", \"===\", \"instance_variables\", \"__id__\", \"eql?\", \"to_s\", \"di\r\n splay\"]\r\n >> C.new.public_methods false\r\n => [\"met\"]\r\n\r\nOvviamente la reflection non si limita alla scoperta dei metodi. Possiamo ad esempio scoprire quali variabili sono state definite:\r\n * local_variables() \r\n * global_variables()\r\n * instance_variables()\r\n\r\nci restituiscono degli array contenente i nomi delle variabili.\r\nIn piu\':\r\n * instance_variable_get(nome)\r\n * instance_variable_set(nome,valore)\r\n\r\npermettono di leggere e modificare delle variabili specifiche. Per fare riferimento a @variabile@ possiamo usare un simbolo o una stringa, indifferentemente. \r\nOvviamente abbiamo a disposizione anche:\r\n * const_get(nome)\r\n * const_set(nome,valore)\r\n * constants \r\nche fanno per le costanti quello che gli altri metodi fanno per le variabili. \r\n\r\nQuesti metodi possono sembrare poco utili, ma sono invece fondamentali. Anzitutto permettono di manipolare un programma in maniera molto dinamica e semplice, e poi permettono di evitare tutta una serie di problemi relativi ad @eval()@.\r\n@eval()@ e\', nella maggior parte dei casi, il male. \r\nMa in altri linguaggi sarete costretti ad usare quella, se volete avere il valore di una variabile partendo dal nome.\r\nIn ruby, per fortuna, potete evitarlo.\r\n\r\nIl vero mostro della reflection e\', comunque, il modulo [[ObjectSpace|UsareObjectSpace]]\r\n');
INSERT INTO `revisions` VALUES (234,198,16,'2005-11-25 13:01:18','h1.  Rimuovere una Directory\r \n\r\nNon su tutte le piattaforme si ha a disposizione un pratico comando @rm -r /@.\r\nPer quelle dove non si puo\' ruby mette a disposizione il modulo @FileUtils@:\r\n\r\n >> require \'fileutils\'\r\n => true\r\n >> FileUtils.rm_rf \'t\'\r\n => [\"t\"]\r\n\r\nquesto modulo e\' molto utile, e vi risparmia la fatica di dover implementare ogni volta routine complesse e tendenti all\'errore, \r\n\r\n');
INSERT INTO `revisions` VALUES (235,199,16,'2005-11-25 13:01:18','h1.  ri\r \n\r\nri e\' una parte del sistema di documentazione di ruby.\r\nIn ruby si possono aggiungere dei commenti al codice in formato rd , e poi estrarli con il tool [[RDoc]].\r\n\r\nRDoc &#232; in grado di generare output in molti formati, xml, html, chm (help di windows) e ri.\r\n\r\nUna volta che i file database di ri sono stati generati, ada riga di comando basta fare:\r\n prompt>ri Classe\r\n\r\nper vedere una lista de metodi di una classe, e ri metodo per vedere informazioni sul metodo.\r\n\r\nEsempio:\r\n\r\n C:\\>ri\r\n Usage:\r\n\r\n   ri [options]  [names...]\r\n\r\n Display information on Ruby classes, modules, and methods.\r\n _... un sacco di altre cose _\r\n \r\n For help on options, type \'ri -h\'\r\n For a list of classes I know about, type \'ri -c\'\r\n C:\\>ri -c\r\n ---------------------------------------------- Known classes and modules\r\n\r\n     Abbrev, ArgumentError, Array, Base64, Base64::Deprecated,\r\n     Benchmark, Benchmark::Job, Benchmark::Report, Benchmark::Tms,\r\n     Bignum, Binding, CGI, CGI::Cookie, CGI::Html3, CGI::Html4,\r\n     _.... un sacco di altre cose_\r\n C:\\>ri SortedSet\r\n ------------------------------------------------- Class: SortedSet < Set\r\n     SortedSet implements a set which elements are sorted in order. See\r\n     Set.\r\n\r\n \r\n\r\n C:\\Documents and Settings\\gabriele>ri Set\r\n ------------------------------------------------------------- Class: Set\r\n     Set implements a collection of unordered values with no duplicates.\r\n     This is a hybrid of Array\'s intuitive inter-operation facilities\r\n     and Hash\'s fast lookup.\r\n     _.... un sacco di altre cose_\r\n C:\\>ri Set.new\r\n --------------------------------------------------------------- Set::new\r\n     Set::new(enum = nil) {|o| ...}\r\n ------------------------------------------------------------------------\r\n     Creates a new set containing the elements of the given enumerable\r\n     object.\r\n\r\n     If a block is given, the elements of enum are preprocessed by the\r\n     given block.\r\n\r\n\r\nE cosi\' via. Notate che alcune cose nn sono documentate molto bene, purtroppo, ma la maggior parte delle classi hanno una buona documentazione, ricca di esempi.\n');
INSERT INTO `revisions` VALUES (236,200,16,'2005-11-25 13:01:18','h1.  R4PyLibs\r \n\r\nLe librerie a cui siete abituati in python sono spesso disponibili anche per ruby.\r\nEsistono binding con qt, gtk, wxWidget e ovviamente Tk per quel che riguarda le GUI.\r\n\r\nL\'equivalente di pygame, che in realta\' e\' un binding per sdl, e\' appunto rubysdl.\r\n\r\n_chiedetene altre, a me nn vengono in mente_\r\n\r\n');
INSERT INTO `revisions` VALUES (237,201,16,'2005-11-25 13:01:18','h1.  Ruby ed Emacs\r \n\r\nh1. == Estensioni a ruby-mode.el\r \n\r\nLe estensioni che trovate qui vi permettono due cose:\r\n\r\n- Passare il buffer corrente a ruby per l\'esecuzione immediata\r\nall\'interno di Emacs.  L\'esecuzione e` interattiva (il programma puo`\r\ncioe` richiedere input dall\'utente) e non richiede che il buffer sia\r\nsalvato.  Associazione di tasti: `C-c C-c\'.\r\n\r\n- Chiudere il blocco `def...end\' o `do...end\' corrente.  Ancora sulla\r\nriga su cui avete scritto `do\' oppure `end\', viene aggiunto `end\' e\r\nspostato il cursore nel mezzo.  Associazione di tasti: `C-c j\'.\r\n\r\nInoltre le indentazioni vengono impostate a due spazi e consisteranno\r\nsempre in spazi, non in un misto di spazi/tabulatori.\r\n\r\nh1. == Installazione\r \n\r\nCopiate quanto segue in un file ruby-ext.el, preferibilmente da\r\nqualche parte nel load-path di Emacs.  Nel vostro ~/.emacs, aggiungete\r\nquesta riga (se il file &egrave; nel load-path):\r\n\r\n  (require \'ruby-ext)\r\n\r\n...oppure questa (se il file non e` nel load-path o non avete idea di\r\ncosa diavolo sia il load-path):\r\n\r\n  (load-file \"/path/to/ruby-ext.el\")\r\n\r\nNaturalmente a /path/to sostituite il percorso giusto.\r\n\r\nh1. == Sorgente\r \n\r\n  ;;; ruby-ext.el --- utility functions for Ruby mode\r\n  \r\n  ;; Copyright (C) 2003 Massimiliano Mirra (mmirra [at] sanniolug [dot] org)\r\n  \r\n  ;; This file is not part of GNU Emacs.\r\n  \r\n  ;; This file is free software; you can redistribute it and/or modify\r\n  ;; it under the terms of the GNU General Public License as published by\r\n  ;; the Free Software Foundation; either version 2, or (at your option)\r\n  ;; any later version.\r\n  \r\n  ;; This file is distributed in the hope that it will be useful,\r\n  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of\r\n  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\r\n  ;; GNU General Public License for more details.\r\n  \r\n  ;; You should have received a copy of the GNU General Public License\r\n  ;; along with GNU Emacs; see the file COPYING.  If not, write to\r\n  ;; the Free Software Foundation, Inc., 59 Temple Place - Suite 330,\r\n  ;; Boston, MA 02111-1307, USA.\r\n  \r\n  ;;; Commentary:\r\n  \r\n  ;; Extensions for ruby-mode.el.\r\n  \r\n  (defvar ruby-calling-buffer nil\r\n    \"Buffer that ruby-run was called from.\")\r\n  \r\n  (defmacro comint-run-and-return (name program calling-buffer-var &rest switches)\r\n    (let ((buffer-name (concat \"*\" name \"*\")))\r\n      `(save-excursion\r\n         (setq ,calling-buffer-var (current-buffer))\r\n         (pop-to-buffer\r\n        (if (comint-check-proc ,buffer-name)\r\n            ,buffer-name\r\n          (let ((process-buffer (make-comint ,name ,program nil ,@switches)))\r\n            (set-process-sentinel (get-buffer-process ,buffer-name)\r\n                                  (lambda (process event) \r\n                                    (when (string= (buffer-name) ,buffer-name)\r\n                                      (end-of-buffer)\r\n                                      (insert \"\\nProcess: \" event \"\\n\")\r\n                                      (insert \"----------------------------------------------------------------------\\n\"))\r\n                                    (pop-to-buffer ,calling-buffer-var)))\r\n            process-buffer))))))\r\n  \r\n  (defun close-block ()\r\n    (interactive)\r\n    (indent-according-to-mode)\r\n    (end-of-line)\r\n    (when block-initial-delimiter\r\n      (skip-chars-backward \" \\t\")\r\n      (insert block-initial-delimiter))\r\n    (newline)\r\n    (insert block-final-delimiter)\r\n    (indent-according-to-mode)\r\n    (beginning-of-line)\r\n    (open-line 1)\r\n    (indent-according-to-mode))\r\n  \r\n  (defun ruby-run ()\r\n    \"Run current buffer through Ruby in a comint buffer.\"\r\n    (interactive)\r\n    (let ((modp (buffer-modified-p))\r\n          (original-file-name (buffer-file-name))\r\n          (original-buffer-name (buffer-name))\r\n          (temp-directory-name (concat \"/tmp/ruby-\" (getenv \"USER\")))\r\n          (ruby-path (expand-file-name default-directory)))\r\n      (unless (file-accessible-directory-p temp-directory-name) \r\n        (make-directory temp-directory-name))\r\n      (let ((temp-file-name (make-temp-file (concat temp-directory-name \"/src\"))))\r\n        (set-visited-file-name temp-file-name)\r\n        (save-buffer)\r\n        (comint-run-and-return \"ruby running\" \"ruby\" ruby-calling-buffer \"-I\" ruby-path \"-w\" temp-file-name)\r\n        (set-visited-file-name original-file-name)\r\n        (rename-buffer original-buffer-name)\r\n        (set-buffer-modified-p modp))))\r\n  \r\n  (defun ruby-custom-setup ()\r\n    (define-key ruby-mode-map \"\\C-cj\" \'close-block)\r\n    (define-key ruby-mode-map \"\\C-c\\C-c\" \'ruby-run)\r\n    (setq tab-width 2\r\n          indent-tabs-mode nil\r\n          ruby-deep-arglist nil\r\n          ruby-deep-indent-paren nil)\r\n    (set (make-variable-buffer-local \'block-initial-delimiter) nil)\r\n    (set (make-variable-buffer-local \'block-final-delimiter) \"end\")\r\n    (set (make-variable-buffer-local \'parens-require-spaces) nil))\r\n  \r\n  (add-hook \'ruby-mode-hook \'ruby-custom-setup)\r\n  (provide \'ruby-ext)\r\n\r\nh1. == Test driven development con Emacs\r \n\r\nQuesta estensione ha l\'utilita` maggiore nello sviluppo guidato dai\r\ntest, perche\' rende molto agile e immediato il ciclo\r\nscrivi-testa-esamina-scrivi.\r\n\r\nSi comincia con uno scheletro di questo tipo:\r\n\r\n\r\n    if __FILE__ == $0 or (defined? $TESTING and $TESTING == true)\r\n      require \"test/unit\"\r\n    \r\n    \r\n    end\r\n  \r\nSi decide, o meglio ci si fa un\'idea vaga e apertissima a modifiche,\r\nsu cosa si andra` a scrivere.  Usiamo il solito calcolatore.  (Le\r\nrighe marcate con `+\' qui di seguito sono le aggiunte rispetto\r\nall\'esempio precedente.)\r\n\r\n  #\r\n    if __FILE__ == $0 or (defined? $TESTING and $TESTING == true)\r\n      require \"test/unit\"\r\n    \r\n  +   class TestCalculator < Test::Unit::TestCase\r\n  +      \r\n  +   end\r\n    end\r\n\r\nCominciamo a scrivere degl esempi d\'uso.  Ci chiediamo: se esistesse\r\ngia` da qualche parte il Calculator che mi serve, cosa farebbe, e come\r\ngli direi di farlo?\r\n\r\n  #\r\n    if __FILE__ == $0 or (defined? $TESTING and $TESTING == true)\r\n      require \"test/unit\"\r\n    \r\n      class TestCalculator < Test::Unit::TestCase\r\n  +     def test_addition\r\n  +       calc = Calculator.new\r\n  +       result = calc.add(1, 2)\r\n  +       assert_equal 3, result\r\n  +     end\r\n      end\r\n    end\r\n\r\nSi preme la combinazione di tasti `C-c C-c\', et voila`, vengono\r\neseguiti gli esempi.  Naturalmente sarete salutati da un bel:\r\n\r\n  NameError: uninitialized constant TestCalculator::Calculator\r\n\r\nGli esempi fungono da test.  `Scopo del gioco\' e` ora scrivere il\r\ncodice che fara` passare con successo quei test.  Il test si lamenta\r\ndi non trovare la classe Calculator: rimediamo.\r\n\r\n  + class Calculator\r\n  +   \r\n  + end\r\n    \r\n    if __FILE__ == $0 or (defined? $TESTING and $TESTING == true)\r\n      require \"test/unit\"\r\n    \r\n      class TestCalculator < Test::Unit::TestCase\r\n        def test_addition\r\n          calc = Calculator.new\r\n          result = calc.add(1, 2)\r\n          assert_equal 3, result\r\n        end\r\n      end\r\n    end\r\n    \r\nDi nuovo `C-c C-c\' e stiamo a vedere che succede.\r\n\r\n    NoMethodError: undefined method `add\' for #<Calculator:0x403164fc>\r\n\r\nOra non viene trovato add.  Scriviamo il minimo indispensabile per\r\nportare il test un passo avanti.\r\n\r\n  #\r\n    class Calculator\r\n  +   def add\r\n  +     \r\n  +   end\r\n    end\r\n\r\nRiavviamo i test con `C-c C-c\':\r\n\r\n    ArgumentError: wrong number of arguments (2 for 0)\r\n\r\nAncora... (`!\' indica una linea modificata.)\r\n\r\n  #\r\n    class Calculator\r\n  !   def add(a, b)\r\n   \r\n      end\r\n    end\r\n\r\nRiavviamo i test:\r\n\r\n    <3> expected but was\r\n    <nil>.\r\n\r\nInfine:\r\n\r\n    class Calculator\r\n      def add(a, b)\r\n        return a + b\r\n      end\r\n    end\r\n\r\n`C-c C-c\':\r\n\r\n    1 tests, 1 assertions, 0 failures, 0 errors\r\n\r\nEcco fatto!\r\n\r\nPer proseguire su questa strada, si scrivono altri test nella classe\r\nTestCalculator, si avvia l\'esecuzione, si scrive il codice che fa\r\npassare i test, e cosi` via.\r\n\r\nPoiche\' il nome del metodo che contiene un test, quando il test\r\nfallisce, viene riportato nell\'output, e` una buona idea renderlo\r\nquanto piu` descrittivo possibile.\r\n\r\n  #\r\n    class TestCalculator < Test::Unit::TestCase\r\n      def test_addition\r\n        calc = Calculator.new\r\n        result = calc.add(1, 2)\r\n        assert_equal 3, result\r\n      end\r\n    \r\n  +   def test_calculator_tells_how_long_it_has_been_running\r\n  +     calc = Calculator.new\r\n  +     sleep 1\r\n  +     seconds = calc.uptime\r\n  +     assert seconds >= 1\r\n  +   end\r\n  + end\r\n\r\nQuesto test fallira` (non c\'e` ancora codice che lo fa passare), e\r\nnell\'output dell\'esecuzione si vedra` questo:\r\n\r\n    test_calculator_tells_how_long_it_has_been_running(TestCalculator):\r\n    NoMethodError: undefined method `uptime\' for #<Calculator:0x40315c14>\r\n\r\nInfine: la parte di file contenente i test e` racchiusa in un\r\n`if...end\' per motivi ben precisi:\r\n\r\n1) i test non vengono eseguiti quando il file viene semplicemente letto\r\nda un altro tramite `require\' (salvo il caso 3).\r\n\r\n2) i test vengono eseguiti quando il file viene dato direttamente in\r\npasto a ruby, con `ruby calculator.rb\' o da Emacs.\r\n\r\n3) i test di piu` classi possono essere eseguiti in batteria,\r\nleggendoli con `require\' da un file in cui e` stata impostata la\r\nvariabile globale `$TESTING\' a true.  Esempio:\r\n\r\n  #!/usr/bin/ruby\r\n\r\n  $TESTING = true\r\n\r\n  require \"calculator\"\r\n  require \"spreadsheet\"\r\n  require \"database\"\r\n\r\nVerranno eseguiti i test contenuti in `calculator\', `spreadsheet\' e\r\n`database\'.\r\n');
INSERT INTO `revisions` VALUES (238,202,16,'2005-11-25 13:01:18','h1.  Ruby Language Reference Manual\r \n\r\n');
INSERT INTO `revisions` VALUES (240,204,16,'2005-11-25 13:01:18','h1.  Ruby4J\r \n\r\nQuesta vuole essere una breve introduzione a ruby per chi programma in Java. \r\nNon impararete tutto, ma si spera di poter creare nel lettore almeno un po\' di curiosita\' ;).\r\n\r\n\r\nJava e Ruby hanno alcuni punti di contatto importanti: anzitutto si tratta di linguaggi di livello alto rispetto al C/C++. Entrambi hanno un sistema di garbage collection automatica,  permettono di avere programmi multipiattaforma, sono completamente ad oggetti, e permettono solo l\'ereditarieta\' singola (ma ruby ha strumenti piu\' potenti delle semplici interfacce). \r\n\r\nInoltre entrambi hanno una libreria \"standard\" molto vasta, supporto per la programmazione multithread ed un sistema di moduli/namespace, ed un sistema di gestione degli errori tramite eccezioni.  \r\n\r\n\r\nLe differenze sono nel focus di fondo: ruby e\' fondato sulla semplice idea che le cose debbano essere semplici ed immediate per lo sviluppatore, piu\' che per il compilatore. \r\nRuby e\' un linguaggio con tipi forti ma dinamici, cio\' significa che potete scrivere:\r\n a= 10 # non dichiarate  che si tratta di interi esplicitamente\r\n b= 20\r\n c= a+b \r\n\r\nma non potete scrivere:\r\n a= \"10\"\r\n b=  20\r\n c= a+b #errore!\r\n\r\nUn esempio del fatto che ruby sia pensato per essere veloce e semplice e\' subito evidente nel fatto che non e\' necessario definire una classe @MiaClasse@ con un metodo @public static void main@ per eseguire un \"hello world\". \r\nL\'interprete ruby si preoccupa di definire una classe al posto nostro.\r\nAd esempio, se lanciate la shell interattiva di ruby, _IRB_, potete provare a fare questo:\r\n\r\n irb(main):001:0> puts(self)\r\n main\r\n => nil\r\n\r\n@main@ e\' il nome della classe (in realta\', del modulo) in cui ci troviamo. @self@ e\' grossomodo equivalente al @this@ di java, cioe\' e\' un puntatore all\'oggetto corrente. Come in java possiamo ometterlo quasi sempre. Ad esempio quel metodo @puts@ in realta\' e\' un @self.puts@.\r\nInfine, @nil@ e\' un valore speciale simile al @null@ di java, la funzione @puts@ non si preoccupa di restituire un valore utile, e quindi restituisce @nil@.\r\n\r\nQui vedete subito in uso tre concetti fondamentali di ruby: \r\n * non servono \";\" a fine linea\r\n * _tutto_ ha un valore di ritorno \r\n * ruby e\' _developer oriented_\r\n\r\nQuello che intendo dire e\' che ruby si preoccupa di rendere la vita semplice allo sviluppatore, in ogni situazione. Quindi quando qualcosa puo\' essere fatta dall\'interprete, come ad esempio definire la classe @main@, e\' meglio che lo faccia l\'interprete. \r\nAllo stesso modo, dato che una funzione di output come @puts@ e\' necessaria in praticamente qualunque cosa, ruby la definisce nella classe @Object@, la \"madre\" di tutte le classi, in modo da evitare la fatica di un @System.out.println(obj)@. \r\n\r\n\r\nRispettando il concetto del \"fai tu che a me non va\", avremmo potuto scrivere anche:\r\n irb(main):002:0> puts self\r\n main\r\n => nil\r\ninsomma, omettere le parentesi. \r\nQuando non si crea ambiguita\' possiamo omettere le parentesi intorno agli argomenti di un metodo. Questo e\' un concetto molto piu\' importante di quanto potrebbe sembrare, abbiate pazienza e scoprirete perche\'.\r\n\r\n\r\nh1. = Strutture di controllo:\r \nLe solite strutture di controllo sono disponibili anche in ruby. Notate pero\' che in ruby \r\nvengono considerati falsi solo l\'oggetto \"@false@\" e \"@nil@\", mentre tutto il resto e\' considerato vero. Cio\' significa che ad esempio, 0 (zero) o  \"\" (la stringa vuota) sono comunque considerati veri.\r\n\r\nI costrutti base:\r\n\r\nif then else\r\n >> if 5 > 6 \r\n >>  puts \"incredibile, cinque maggiore di sei!\"\r\n >> end\r\n => nil\r\n >> if  6 > 5\r\n >>  puts \"ah, ok, sei maggiore di cinque..\"\r\n >> end\r\n ah, ok, sei maggiore di cinque..\r\n => nil\r\n\r\nesiste anche un unless-then-else, dove unless (\"a meno che\") e\' equivalente ad un @if not@.\r\n\r\nPotete usare @if@ e @unless@ come @statement modifier@ cioe\' applicarli ad una sola riga, mettendoli alla fine:\r\n\r\n >> puts \'ok\' if true\r\n ok\r\n => nil\r\n >> puts \'il mondo funziona ancora\' unless true == false\r\n il mondo funziona ancora\r\n => nil\r\n\r\nGli operatori di confronto sono quelli comuni (@>@,@<@,@>=@,@<=@,@==@,@!=@) e gli operatori logici anche (@!@, @&&@, @||@ o in inglese @and@, @not@, @or@).\r\n\r\noperatore ternario:\r\n >> 5 > 6 ? \'maggiore\' : \'minore\'\r\n => \"minore\"\r\n \r\nciclo while:\r\n >> x=0\r\n => 0\r\n >> while x < 5\r\n >>  puts x\r\n >>  x+=1\r\n >> end\r\n 0\r\n 1\r\n 2\r\n 3\r\n 4 \r\n => nil\r\n\r\n(notate che non esiste un operatore \"@++@\" in ruby, in quanto le variabili sono solo nomi per gli oggetti. Dunque scrivere 5++ significherebbe \"il 5 deve diventare 6\" che non ha molto senso :)\r\n\r\nAbbiamo poi il case/switch: \r\n >> while true\r\n >>  case gets.chomp # gets legge una stringa da input, chomp toglie lo \\n\r\n >>   when \'ciao\'\r\n >>    puts \"ciao a te\"\r\n >>   when \'addio\'\r\n >>    puts \"a presto\"\r\n >>  end\r\n >> end\r\n ciao\r\n ciao a te\r\n addio\r\n a presto\r\n\r\npotete aggiungere una clausola \"@else@\" per gestire il caso di default. \r\nIl funzionamento del @case@ e\' molto intelligente: si basa sull\'operatore \"@===@\" (in ruby gli operatori sono semplici metodi chiamati diversamente) detto di \"case equality\". Dato che questo operatore e\' definito in maniera intelligente per ogni classe, il costrutto @case@ diventa molto piu\' potente di quello di java o c. Ad esempio, per la class @Regexp@ l\'operatore rappresenta il match su di una stringa, per una classe il fatto che un oggetto ne sia istanza, e cosi\' via:\r\n\r\n >>  /^c/ === \'ciao\' # /^c/ e\' una Regexp, === significa \"corrisponde alla Regexp\"\r\n => true\r\n >> String === \'ciao\' # String e\' una Classe, === significa \"istanza della Classe\"\r\n => true\r\n >> (1..10) === 5 # 1..10 e\' un oggetto Range, === significa \"nel Range\"\r\n => true\r\n \r\n\r\nOvviamente non userete mai l\'operatore di case equality da solo come in questo caso, ma quasi unicamente dall\'interno di un @case@.\r\n\r\nL\'ultima struttura di controllo di cui parler&#242; &#232; il @for..end@.\r\n\r\nIn pratica si tratta del solito @for@ comune nei linguaggi di scripting:\r\n\r\n >> for i in 1..10\r\n >>  print i\r\n >> end\r\n 12345678910=> 1..10\r\n\r\nLa magia sta nel fatto che in realt&#224; il @for@ fa uso di un meccanismo simile al modello degli iteratori in java.\r\nIn pratica ogni classe definisce un metodo @each@ il quale restituisce ogni elemento della collezione. Cosi\', ad esempio un oggewtto @Range@ fornisce i valori da 1 a 10, un @Array@ i suoi elementi, ed un @Hash@ delle coppie chiave/valore.\r\n\r\n@for@ di nascosto usa questo metodo. Ma in realts\' possiamo essere noi stessi ad usarlo direttamente:\r\n\r\n >> a=[1,20,3,40,5] # un Array puo\' essere definito [elemento,elemento]\r\n => [1, 20, 3, 40, 5]\r\n >> a.each do |elemento| # tra le | si mettono i nomi degli argomenti passati \r\n ?>  puts elemento\r\n >> end\r\n 1\r\n 20\r\n 3\r\n 40\r\n 5\r\n => [1, 20, 3, 40, 5]\r\n\r\nil blocco @do..end@ e\' la maggior parte della magia di ruby.\r\nInfatti permette di definire un oggetto chiamato @Proc@ che altro non e\' che un pezzetto di codice, una funzione anonima, una [[FormaLambda]]. \r\n\r\nPotendo passare un pezzo di codice qua e la\' potete crearvi le vostre strutture di controllo, ad esempio:\r\n\r\n connessione_a_database.transazione do  #inizio transazione\r\n   ..esegui inserimento..\r\n   ..esegui cancellazione..\r\n end # commit o rollback\r\n\r\n\r\noppure rendere generali dei meccanismi semplici come l\'ordinamento:\r\n >> a\r\n => [1, 20, 3, 40, 5]\r\n >> a.sort # metodo builtin, paragona il semplice valore\r\n => [1, 3, 5, 20, 40]\r\n >> a.sort_by {|elem| elem % 19 } # ordina basandosi sul valore di ritorno del blocco\r\n => [1, 20, 40, 3, 5]\r\n ==persone.sort_by {|pers| pers.cognome, pers.nome, pers.sesso }\r\n\r\nnota: potete usare una coppia di parentesi graffe al posto del @do..end@, sono gusti.\r\n\r\nNon esiste limite a quel che si puo\' fare con i blocchi. Potete implementare la maggior parte dei meccanismi della progrmmazione funzionale, applicare trasformazioni complesse a strutture dati ancor piu\' complesse, localizzare e fattorizzare operazioni ripetitive.. \r\n\r\nI blocchi sono una cosa talmente utile che esistono persino framework per usarli in java :)(mini esempio: [[BlocksInJava sul wiki di ward|URL:http://c2.com/cgi/wiki?BlocksInJava]]\r\n\r\nh1. = Metodi\r \n\r\n Abbiamo visto come si crea una classe. Come si fa a definire un metodo? \r\n facile:\r\n  >> def met (arg1,arg2)\r\n  >>  puts arg1,arg2\r\n  >> end\r\n cioe\' : @def@ nomemetodo argomenti @end@\r\n\r\nin realta\' rispettando la regola che le cose ovvie possono essere omesse potreste scrivere:\r\n\r\n >> def met arg1, arg2\r\n >>  puts arg1,arg2\r\n >> end\r\n\r\ncioe\' evitare le parentesi. In generale non e\' uno stile molto diffuso, ma alcuni (ad esempio Martin Fowler) lo usano. De gustibus :) \r\n\r\nnotate che non specifichiamo il tipo delle variabili, e quindi non si puo\' avere iverload dei metodi. Ok, in realta\' esistono librerie che permettono sia di specificare i tipi che di avere funzioni \"overloadate\", ma non sono molto usate. \r\n\r\nNel definire i metodi possiamo anche dire a ruby di accettare un numero variabile di argomenti:\r\n >> def met( *args)\r\n >>  puts args.class\r\n >>  puts args\r\n >> end\r\n => nil\r\n irb(main):041:0> met 1, 2 ,3 ,4 ,5\r\n Array\r\n 1\r\n 2\r\n 3\r\n 4\r\n 5\r\n => nil\r\n\r\ncome vedete ruby raccoglie tutti gli argomenti nella variabile prefissata con un \"@*@\", mettendoli dentro un @Array@. \r\nIl fatto di vedere tutti gli elementi stampati uno per linea dipende da @puts@, che controlla se l\'oggetto e\' un @Array@ ed in quel caso ne stampa gli elementi uno per linea. \r\n\r\nE\' anche possibile assegnare dei valori di default alle variabili:\r\n\r\n >> def stampa_persona( nome=\'mario\', cognome=\'rossi\')\r\n >>  print \"il signor \" + nome + \" \" + cognome\r\n >>  print \"\\n\"\r\n >> end\r\n => nil\r\n >> stampa_persona \'franco\', \'bianchi\'\r\n il signor franco bianchi\r\n => nil\r\n >> stampa_persona \'franco\'\r\n il signor franco rossi\r\n => nil\r\n >> stampa_persona\r\n il signor mario rossi\r\n => nil\r\n\r\n\r\nL\'ultima cosa che dovreste chiedervi e\': come faccio a gestire un blocco?\r\nEsistono due modi. L\'unico che vi spieghero\' e\' usando la keyword @yield@:\r\n\r\n >> def due\r\n >>  yield 1\r\n >>  yield 2\r\n >> end\r\n => nil\r\n >> due {|x| p x }\r\n 1\r\n 2\r\n\r\nSe non gli passiamo un blocco:\r\n\r\n>> due\r\nLocalJumpError: no block given\r\n        from (irb):26:in `due\'\r\n        from (irb):30\r\n        from &#9829;:0\r\n\r\ndunque un modo migliore di scrivere sarebbe:\r\n\r\n >> def due\r\n >>  yield 1,2 if block_given?\r\n >> end\r\n => nil\r\n >> due {|x,y| puts x,y }\r\n 1\r\n 2\r\n => nil\r\n >> due\r\n => nil\r\n\r\ne qui scopriamo un altro paio di cose: non siamo limitati ad usare le lettere [_a-z] nel dare nomi ai metodi.\r\n\r\nPossiamo infatti usare alcuni altri caratteri, come @!@ e @?@.\r\n\r\nIn generale si usa un metodo che finisce in @?@ per i metodi che restituiscono valori boleani. In questo caso era:\r\n viene passato un blocco? si o no\r\n\r\naltri esempi:\r\n >> 5.is_a? Numeric\r\n => true\r\n >> String.respond_to? \'+\'\r\n => false\r\n >> \"String\".respond_to? \'+\'\r\n => true\r\n\r\nI metodi con un punto esclamativo sono ispirati alla tradizione del linguaggio [[Scheme]] ed altri, e rappresentano metodi che in qualche modo sono \"pericolosi\". \r\nAd esempio, guardate il metodo @sort@ egli @Array@:\r\n >> a=[1,2,23,434,1,23,3,123]\r\n => [1, 2, 23, 434, 1, 23, 3, 123]\r\n >> a.sort\r\n => [1, 1, 2, 3, 23, 23, 123, 434]\r\n >> a\r\n => [1, 2, 23, 434, 1, 23, 3, 123]\r\n\r\ncome vedete @a@ non e\' stato modificato. Guardate ora:\r\n >> a.sort!\r\n => [1, 1, 2, 3, 23, 23, 123, 434]\r\n >> a\r\n => [1, 1, 2, 3, 23, 23, 123, 434]\r\n\r\nIn questo caso @a@ viene modificato, cioe\' @sort!@ fa [[side effect]].\r\nI punti esclamativi sono li per dire:\r\n\"_ok, magari questo metodo e\' piu\' veloce dell\'altro, ma usalo con un po di testa, perche\' potresti fare casino_\". Anche in questo caso il linguaggio non ci impone delle cose, semplicemente cerca di darci dei consigli. \r\n\r\nAn diamo avanti. Seguendo l\'esempio di java definiamo una semplice classe:\r\n\r\n irb(main):003:0> class Foo\r\n irb(main):004:1> end\r\n => nil\r\n\r\nsemplice semplice. Notate che abbiamo un valore di ritorno anche per la dichiarzione di una classe.\r\nNotate anche che non e\' necessario, in ruby, definire una sola classe pubblica per file. \r\nIn effetti \'pubblica\' non e\' nemmeno un qualcosa che si applichi ad una classe in ruby.\r\nUna cosa importante e\' che una classe _deve_ avere un nome che inizi con la lettera maiuscola:\r\n irb(main):005:0> class foo\r\n irb(main):006:1> end\r\n SyntaxError: compile error\r\n (irb):5: class/module name must be CONSTANT\r\n         from (irb):6\r\n\r\nInfatti, ruby adotta il sistema comune di dare un nome maiuscolo alle costanti come regola. In questo modo lo sviluppatore e\' indirizzato verso uno stile comune in modo gentile. Potete sempre scrivere: \r\n irb(main):007:0> miao=Foo\r\n => Foo\r\n\r\ned usare @miao@ come classe, semplicemente ruby _spinge_ per un\'approccio differente. Comunque, a questo punto abbiamo visto altri quattro concetti:\r\n* non esiste una keyword @final@. Le costanti sono scritte con una lettera maiuscola\r\n* l\'assegnazione avviene come in java:  \r\n nomevariabile= valore \r\n* una variabile viene dichiarata nel momento in cui gli viene assegnato un valore. \r\n* una variabile non ha un tipo. L\'oggetto a cui la variabile si riferisce si:\r\n irb(main):008:0> miao.class\r\n => Class\r\n irb(main):009:0> a=\'ciao\'\r\n => \"ciao\"\r\n irb(main):010:0> a.class\r\n => String\r\n irb(main):011:0> 5.class\r\n => Fixnum\r\n irb(main):012:0> \'ciao\'+5\r\n TypeError: cannot convert Fixnum into String\r\n        from (irb):12:in `+\'\r\n        from (irb):12\r\n\r\ncome vedete ruby lancia un\'eccezione nel caso si cerchi di mischiare tipi differenti. \r\nInfatti ruby e\' un linguaggio _fortemente tipato_, semplicemente i tipi non sono nelle variabili ma sono negli oggetti, si parla dunque di _tipi forti dinamici_, in contrasto con java (_tipi forti statici_). \r\n\r\nNotate che anche se javac fa del suo meglio per cercare errori di tipo in fase di compilazione, alcuni gli sfuggeranno sempe e causeranno eccezioni a runtime, esattamente come in ruby. \r\n\r\n');
INSERT INTO `revisions` VALUES (241,205,16,'2005-11-25 13:01:18','h1.  RubyForPythonista\r \n\r\nDate un\'occhiata anche a [[Ruby For Pythonista: Le Librerie|Ru4PyLibs]]\r\nUn\'altro confront (in inglese [[e\' qui|URL:http://c2.com/cgi/wiki?PythonVsRuby]]\r\n\r\nPerdonate le inesattezze e vogliate correggerle quando le notate. \r\nIn realta\' Ruby e python sono talmente diversi da essere identici. \r\nSe avete dei dubbi su come venga realizzato un determinato meccanismo/comportamento\r\nin ruby chiedete in mailing list o su questa pagina\r\n\r\nQuesta pagina e\' dedicata a chi ama python, ma non e\' un fondamentalista.\r\nCon cio\' intendo dire che mentalita\' del tipo\r\n *  python mi piace\r\n *  python e\' adatto a quello che faccio\r\n *  amo tutti i linguaggi \r\n *  ho sentito dire che ruby e\' un bel linguaggio\r\n *  python e\' il miglior linguaggio che conosco\r\n\r\nsono ok.\r\n\r\nAl contrario approcci come\r\n * python e\' perfetto\r\n * non ne ho mai provato un altro ma so che gli altri fanno schifo\r\n * le feature di qualsiasi altro linguaggio sono inutili\r\n * python ha tutto quello che voglio \r\ne tutti i vari esempi di [[BLUB Paradox|BLUBParadox]] non sono ok.\r\n\r\nIo posso cercare di spiegare solo se siete disposti ad imparare :)\r\n\r\nh1. == Similitudini\r \nRuby e python sono simili soprattutto _nello spirito_. \r\nEntrambi:\r\n * sono semplici\r\n * sono pragmatici\r\n * permettono di programmare in stile OO  \r\n * permettono di programmare in stile procedurale\r\n * permettono di programmare in stile funzionale\r\n * hanno una libreria molto vasta e potente\r\n * sono molto compatti\r\n * hanno strutture dati di alto livello integrate (Hash, Array dinamici)\r\n\r\nh1. == Differenze  \r \nruby e python differiscono fondamentalmente come _storia _, e sono un interessante esempio di affinita\' elettive. \r\nInfatti, mentre python nasce come linguaggio procedurale, sul quale hanno poi aggiunto OOP e meccanismi come gli iteratori, ruby li aveva dall\'inizio. \r\nNel contempo, scelte come le variabili di classe locali alla classe, sono state introdotte in ruby in seguito (inizialmente esse erano condivise dalle sottoclassi) mentre erano nella prima OO in python. \r\n\r\n\r\nIn ordine sparso:\r\n*Python ha funzioni e oggetti nello stesso namespace\r\n*In ruby le funzioni esistono solo come messaggi ad oggetti\r\n*Ruby ha chiusure lessicali [[lambda|FormaLambda]] come quelle del LISP\r\n*In ruby si possono cambiare gli oggetti base in python no\r\n*Alcune cose sono arbitrarie in python (i.e. il @self@) e hanno una logica in ruby\r\n*.. e viceversa probabilmente :)\r\n*In ruby tutto e\' un\'espressione \r\n*Gli iteratori in ruby sono basati su metodi anonimi, in python sono semicoroutine\r\n*In ruby esiste un vero controllo d\'accesso (privato/pubblico/protetto)\r\n*Python ha le list comprehension che in ruby vengono sostituite dai blocchi.\r\n*Ruby ha continuazioni manipolabili (first class reified continuation)\r\n*Python ha l\'ereditarieta\' multipla\r\n*Ruby ha i mix-in\r\n*Python ha i keyword argument\r\n*In ruby non esistono classi vecchio e nuovo stile, ne\' descrittori,\r\n ne\' ci sono differenze tra funzioni e metodi. \r\n*I blocchi in ruby coprono le funzionalita\' che in python sono sparse tra iteratori, *lambda, funzioni e list comprehension. \r\n*In python si usano i descrittori per creare metodi di classe, in ruby si \r\n tratta di metodi singleton. \r\n*In python un oggetto e\' fondamentalmente un dizionario.\r\n*In ruby tutti gli oggetti sono _mutabili_, ma possono essere \r\n bloccati con @freeze()@\r\n*In ruby si puo\' usare qualsiasi cosa come chiave di un dizionario (@Hash@)\r\n\r\n\r\nVedere anche [[Classi a Runtime in Ruby e Python]]\n');
INSERT INTO `revisions` VALUES (242,206,16,'2005-11-25 13:01:18','h1.  RubyHaiku\r \n\r\nGli haiku sono una forma di poesia Giapponese molto affascinante.\r\nL\'intera poesia e\' caratterizzata da una lunghezza di 17 sillabe, nelle quali viene raccolto tutto il sentimento dell\'autore.\r\n\r\nRuby, a sua volta e\' un linguaggio molto affascinante, e permette di esprimere in poche righe di codice concetti anche molto complessi.\r\n\r\nQuesta pagina raccoglie alcuni spezzoni (forse spezzini?) che mostrano la potenza di ruby in un massimo di 17 righe.\r\n\r\nEffetivamente in diciassette righe di ruby si puo\' fare qusi tutto, quindi stabiliremo un limite a 9 righe in modo da poter dire \"io lo faccio in meno di dicei righe!\" ^_^\r\n\r\n(sentitevi liberi di firmare le vostre aggiunte)\r\n\r\n+pseudo portscanner\r\nuso: ruby nomefile.rb startport endport\r\n require \'socket\'\r\n addr,sport,eport=ARGV[0],ARGV[1].to_i,ARGV[2].to_i\r\n puts \"porte aperte:\"\r\n sport.upto(eport) {|x| puts x if (TCPSocket.new (addr,x) rescue false)  }\r\n\r\n\r\n+echoserver multithread\r\n require \'socket\'\r\n server = TCPServer.open(1234)\r\n while true\r\n  Thread.start(server.accept) do |s|\r\n     s.puts(s.gets)\r\n  end\r\n end\r\n\r\n+webserver\r\nWEBrick permette di creare facilmente server HTTP/HTTPS,SOAP..\r\nE\' un modulo standard in ruby1.8, libreria esterna nell\'1.6\r\n\r\n require \'webrick\'  include WEBrick\r\n s = HTTPServer.new(\r\n  :Port            => 2000,\r\n  :DocumentRoot    => \"/\"\r\n )\r\n s.mount(\"/nomedir\", HTTPServlet::FileHandler, \'lamia_dir\',true)\r\n s.start\r\n\r\n\r\n+controllo cambi\r\nun semplice strumento per recuperare il cambio euro-dollaro da yahoo:\r\n require \'net/http\'\r\n input = Net::HTTP.get \"it.finance.yahoo.com\", \"/d/quotes.csv?s=EURUSD=X&f=sl1d1t1c1ohgv\"\r\n c,d,t=input.split(/,/)[1..-1]\r\n puts \"EUR/USD:   #{c}   (#{d} , #{t})\"\r\n\r\n+rgrep\r\nun rimpiazzo minimale per il comando \'grep\'\r\n regex = /#{ARGV.shift}/\r\n ARGF.each { |line| puts line if regex.match(line) }\r\n\r\n+md5sum\r\nuno script equivalente al comando md5sum, che genera la stringa esadecimale corrispondente \r\nall\'hash del file dato\r\n ruby -r md5 -e \"puts MD5.new(File.open(\'filename\', \'rb\').read).hexdigest\"\r\n\r\n+cdplayer\r\nquesto e\' un micro player di cd audio:\r\nPer usarlo avviate irb e caricate lo script. \r\nPer suonare il brano X basta scrivere \'play X\' (ad.es. \'play 5\') e per bloccarlo \'stop\'\r\n require \'sdl\'\r\n SDL.init( SDL::INIT_CDROM )\r\n (Cd=SDL::CD.open(0)).status\r\n def play(trk)\r\n  Cd.playTracks(trk,0,0,0)\r\n end\r\n def stop\r\n  Cd.stop\r\n end\r\nlo script richiede la libreria Ruby/SDL\r\n\r\n+webserver\r\nPoiche\' ruby ha nella libreria standard uno splendido modulo chiamato @WEBrick@ che permette di costruire applicazioni web _partendo dal webserver_, e\' ovvio che esiste un semplice oneliner per creare un server che mostri il contenuto della directory corrente:\r\n ruby -rwebrick -e \'WEBrick::HTTPServer.new(:DocumentRoot=>\".\").start\'\r\nLa porta sara\' la 80 di default.\r\n\r\n\r\n+quicksort da 6 righe:\r\n\r\n def qsort(list)\r\n  return [] if list.size == 0\r\n  x, xs = *list\r\n  less, more = xs.partition{|y| y < x}\r\n  qsort(less) + [x] + qsort(more)\r\n end\r\n\r\ne da cinque righe:\r\n def qs(l)\r\n  return [] if (x,*xs=*l).empty?\r\n  less, more = xs.partition{|y| y < x}\r\n  qs(less) + [x] + qs(more)\r\n end\r\n\r\n(e\' possibile farlo arrivare a tre righe, ma diventa stupido, usando due iterazioni ogni volta.)\n');
INSERT INTO `revisions` VALUES (243,207,16,'2005-11-25 13:01:18','h1.  RubyQuiz del mese\r \n\r\nOgni mese cercheremo di proporre un problema. In genere chiederemo di scrivere un breve\r\nprogramma o un metodo o una classe. Tutti possono partecipare alla\r\nsoluzione sia con soluzioni complete sia con suggerimenti.\r\nI suggerimenti, le domande, o anche delle semplici considerazioni vanno\r\ninserite nella sezione \"discussioni\" relativa al quiz del mese.\r\n\r\nNon ci sono premi ne\' riconoscimenti, ma l\'unico scopo della competizione\r\ne\' quello di produrre del buon codice.\r\n* [[Quiz Ottobre 2004]]\r\n* [[Quiz Agosto 2004]]\r\n   *[[soluzione di gabriele renzi|URL:http://ada2.unipv.it/pipermail/ruby/2004-September/000529.html]]\r\n* [[Quiz Maggio 2003]]\r\n\r\n\r\n* [[Quiz Aprile 2003]]\r\n   *  [[Soluzione Aprile 2003 di Luigi Panzeri]]\r\n   *  [[Soluzione Aprile 2003 di Gabriele Renzi]]\r\n\r\n* [[Quiz Marzo 2003]]\r\n   *  [[Soluzione Marzo 2003 di Luigi Panzeri]]\r\n\r\n* [[Quiz Febbraio 2003]]\r\n   *  [[Soluzione Febbraio 2003 di Gabriele Renzi]]\r\n   *  [[Soluzione Febbraio 2003 di Massimiliano Mirra]]\r\n   *  [[Soluzione Febbraio 2003 di Kirash]]\r\n\r\n\r\nh1. = NubyQuiz del mese\r \n* [[NubyQuiz Giugno 2003]]\r\n\r\n');
INSERT INTO `revisions` VALUES (244,208,16,'2005-11-25 13:01:18','h1.  ScuseFrequenti\r \n\r\n\r\nSpesso parlando di Ruby con qualcuno ci si sente dire _\'Si, userei ruby ma..\'_\r\nEbbene, questa pagina vuole essere una raccolta di scuse frequenti.\r\nCi sono ottimi motivi per non usare Ruby, e soprattutto se nel vostro linguaggio preferito ci sono gia\' tutte le cose di cui avete bisogno, non avrete bisogno di cambiarlo.\r\n\r\nMa se vorreste cambiare e non lo fate per ((|questi|)) motivi.. beh, sono solo scuse ;P\r\n\r\nh1. == ...tutte quelle variabili alla Perl!\r \nIn ruby esistono le variabili stile perl come $\\ , $_ ,$~ e\' vero.\r\nD\'altronde l\'uso di queste variabili e\' fortemente scoraggiato, \r\ned e\' possibile farne a meno senza alcun problema.\r\nAd esempio, facendo un ((%grep \'\\$\' *%)) sulla libreria YAML.rb si scopre che ci sono\r\n36 righe con un dollaro su 1910 righe di codice. E non dimenticate che con il dollaro \r\nsi indicano _tutte_ le variabili globali ed e\' un metacarattere molto comune nelle Regexp.\r\n\r\n\r\nh1. == ...i ritorni impliciti!\r \nAlcuni ritengono che\r\n def met(x,y)\r\n  return x,y\r\n end\r\n\r\nsia molto piu\' chiaro di\r\n def met(x,y)\r\n  x+y\r\n end\r\n\r\nforse e\' cosi\'.. ma potete usare tranquillamente quello che preferite :)\r\n\r\nh1. == ...ma le variabili globali con il dollaro davanti fanno tanto line noise!\r \nVero, sono pensate in modo da scoraggiarne l\'uso.\r\nI programmi in ruby, molto spesso, usano pochissime o nessuna variabile globale.\r\nLe variabili globali, spesso sono causa di bug subdoli e andrebbero evitate in qualsiasi linguaggio, in Ruby, se ne scoraggia l\'uso implicitamente. Per evitare il fastidio visivo, basta fare la cosa giusta: Raccogliere le variabili in un modulo o classe, usare una costante se possibile,  usare una variabile locale.\r\n\r\n\r\nh1. == ...ma e\' completamente ad oggetti!\r \nEssere ad oggetti non implica che bisogni scrivere codice in stile OO.\r\n \r\nquesto e\' comune codice procedurale:\r\n\r\n def doppio(x)\r\n  return x*2\r\n end\r\n\r\n val=gets\r\n puts(doppio(val))\r\n\r\ne lo stesso si puo\' fare anche per codice in stile funzionale.\r\n\r\nh1. == ...ma non supporta il paradigma funzionale!\r \nVero, ruby e\' a oggetti, punto. Ma una delle principali fonti di ispirazione per ruby e\' LISP.\r\n[[Questa pagina|URL:http://www.ping.de/~flori/flott/exe/session/project/ruby/functional]] potrebbe convincervi :) \r\n\r\n\r\nh1. == ...si possono modificare le classi! E\' insicuro!\r \nD\'altronde, anche in C si puo\' mettere in un header\r\n #define char int\r\n\r\nma nessuno si sogna di farlo :)\r\n\r\nAvere classi aperte e\' una cosa utile in quanto e\' possibile _aggiungere_ delle funzionalita` alle classi base, evitando di doverle subclassare in molti casi.\r\nD\'altronde, e\' piuttosto raro che qualcuno pensi di cambiare il comportamento di \r\n((\'Array#sort()\')) o String#== .\r\n\r\nSpesso si sente dire che in progetti complessi avere le classi aperte sarebbe un problema:\r\ncome fidarsi dei propri colleghi?\r\nSiamo seri: vi sembra ragionevole che qualcuno cambi il comportamento di Hash#length e il resto del team non lo sappia? ;)\r\n\r\nOk, vi sembra probabile.\r\n Beh con $VERBOSE=true (default in 1.8) ruby emette un warning nel caso di ridefinizione di un metodo. \r\n Oppure potete effettuare il freeze della classe e generare un eccezione in caso di modifica.\r\n Se siete ultraparanoici ( ma davvero ultra) potete settare $SAFE=4 e ottenere ancora una bella eccezione :)\r\n\r\nDa notare anche che un comportamento simile a quello di Ruby e\' permesso anche da SmallTalk dall\'ObjectiveC e da Python (per alcuni oggetti), eppure ci sono diversi progetti che li usano e funzionano egregiamente..\r\n\r\n\r\nh1. == ... ma ci sono poche librerie!\r \nDi quale in particolare senti il bisogno?\r\nEsistono numerosi binding a GUI (GTK,wxWindows,FOX,TK,FLTK etc..), molti dbms, librerie per lo sviluppo web, xml, SOAP,XML-RPC, YAML, librerie di rete, parser lessicali/sintattici, OLE, COCOA, POSIX, librerie per la creazione di PDF/XSL/RDF/SVG/immagini varie, per l\'uso delle seriali o per le smartcard, per OpenGL, SDL...\r\n\r\nIn ogni caso, provate a chiedere su comp.lang.ruby, e\' probabile che la libreria di cui avete bisogno esista gia`..\r\n\r\nh1. == ... ma nessuno usa davvero ruby! si tratta di un linguaggio giocattolo!\r \nNASA, Motorola, Siemens, Lucent sono solo alcuni dei nomi che si possono leggere [[in questa pagina|URL:http://www.rubygarden.org/ruby?RealWorldRuby]], dove sono raccolte delle \'storie di successo\' relative all\'uso di Ruby. Ma il punto e\' un altro: cosa importa se altri usano/non usano ruby, se _IO_ posso essere piu\' produttivo usandolo?\n');
INSERT INTO `revisions` VALUES (245,210,16,'2005-11-25 13:01:18','h1.  SingletonClass\r \n\r\n((*Questa spiegazione e\' stata data da Guy Decoux, uno dei superhacker di ruby\r\n(intendendo l\'interprete) su comp.lang.ruby/ruby-talk. Viene qui riportata in italiano sperando possa esere utile a chi vuole capire meglio ruby.\r\nL\'intero thread puo\' essere letto [[qui|URL:http://ruby-talk.org/cgi-bin/vframe.rb/ruby/ruby-talk/104272?104153-104355+split-mode-vertical]]: \r\nLa notazione per indicare i metodi e\' quella comune: @Classe::metodo_di_classe()@ e @Classe#metodo_di_istanza()@*))\r\n\r\n\r\n\r\nRuby ha solo degli oggetti, cio\' significa che una classe e\' un oggetto e come ogni oggetto ha una classe (@Class@) dove sono definiti i suoi metodi.\r\n\r\nCio\' significa che, ad esempio, il metodo @::new()@ e\' definito nella classe @Class@,\r\ned e\' una cosa del genere\r\n\r\n   class Class\r\n      def new(*args, &block)\r\n         obj = allocate\r\n         obj.send(:initialize, *args, &block)\r\n         obj\r\n      end\r\n   end\r\n\r\n_ @allocate()@ e\' il metodo della classe @Class@ che serve ad, appunto, allocare un certo spazio di memoria trasformandolo in un oggetto_\r\n\r\nCio\' funziona perfettamente, ma e\' facile vedere che esiste un problema. \r\nSe e\' stato semplice definire @::new()@, sarebbe piu\' arduo definire @::allocate()@ nello stesso modo, poiche\' @Array::allocate()@ e\' completamente differente da @Hash::allocate()@ e non sarebbe bello definire un metodo @Class#allocate()@ come un enorme switch e cambiarlo ogni volta che viene introdotta una nuova classe.\r\n\r\nUn ulteriore problema si presenta nel caso si voglia definire un metodo\r\n@File::open()@, che possa accettare in input un blocco. \r\nNon e\' possibile definire tale metodo in @Class@\r\n(come @Class#open()@) poiche\' cio\' significherebbe definire anche @Array::open()@,\r\n@Hash::open()@ e ovviamente non vogliamo una cosa simile.\r\n\r\nPer risolvere questi due problemi, ruby associa ad ogni classe un oggetto e quando cerca un metodo di classe cerca prima in questo oggetto, e poi in @Class@.\r\n\r\nOra ruby puo\' funzionare, perche\'\r\n   * il metodo @::allocate()@ puo\' essere definito in questo oggetto speciale,\r\n     avendo ancora  @Class#new()@\r\n\r\n   * potete definire nell\'oggetto associato a @File@, il metodo @::open()@\r\n     e solo questa classe avra\' quel metodo\r\n\r\nMa una classe e\' un po\' speciale poiche\' esiste l\'ereditarieta\' e quando viene scritto\r\n\r\n    class A < Array\r\n    end\r\n\r\nVogliamo riusare, per @A@, il metodo @::allocate()@ che e\' stato definito nell\'oggetto speciale associato con @Array@\r\n\r\ncio\' significa che per quell\'ogetto speciale, associato con una class, si vuole\r\n   * la possibilita\' di definire un metodo\r\n   * la possibilita\' di usare l\'ereditarieta\'\r\n\r\nesiste un oggetto che e perfetto per questo scopo, ed e\' esattamente una classe, e dato che questa classe sara\' sempre associata con _un solo_\r\naltro oggetto viene detta _\"singleton class_, classe singolare. \r\n\r\nPer finire, cio\' ci da\' questo: (dove @(A)@ e\' la singleton class associata con \r\n@A@)\r\n\r\n    Class  <  Module  <  Object\r\n   (Class) < (Module) < (Object) < Class\r\n                               \r\n      A    <  Array  <  Object \r\n     (A)   < (Array) < (Object)\r\n\r\nE questo e\' lo schema che si trova nel file @object.c@\r\n\r\nOra, al principio, abbiamo detto che una classe e\' un oggetto ed abbiamo introdotto la singleton class. Cio\' significa poter associare una classe singolare ad ogni oggetto,\r\ne facendo cio\' ottenere dei metodi specifici per quell\'oggetto, ad esempio\r\n\r\n   a = []\r\n   class << a\r\n      def tt\r\n      end\r\n   end\r\n\r\nQuando ruby dovra\' cercare un metodo in @a@, cerchera\' prima nella sua classe singolare e poi nella sua classe.\r\n\r\nGuy Decoux\r\n\r\n\r\n\r\n \n');
INSERT INTO `revisions` VALUES (246,211,16,'2005-11-25 13:01:18','h1.  Sol. 04/03 di Gabriele Renzi\r \n\r\nla soluzione e\' simile nel concetto a quella di Luigi, ma la variabile in cui vengono\r\nmantenute le informazioni e\' una variabile d\'istanza di un oggetto Memoize.\r\nNel codice e\' presente un controllo sul blocco che viene passato, ma in realta`, non so perche\', con i blocchi non funziona.\r\nQuindi in realta`, i vari &blk possono essere tolti.\r\nIn compenso funziona sia con parametri singoli, che con parametri assenti o variabili (*arg)\r\n\r\n class Memoize\r\n  def initialize(sym)\r\n    @met=method(sym)\r\n    @val=Hash.new\r\n  end\r\n  def call(*args,&block)\r\n   if not @val[[args,block]]\r\n    @val[[args,block]]=@met.call(*args,&block)\r\n   end\r\n    @val[[args,block]]\r\n  end\r\n end\r\n\r\nche bello che ruby permetta di mettere qualunque cosa come chiave dell\'hash :)\r\n');
INSERT INTO `revisions` VALUES (247,212,16,'2005-11-25 13:01:18','h1.  Soluzione 04/03 di Luigi Panzeri\r \n\r\nPeccato che memoize vada chiamata in un modo cosi\' strano.\r\n\r\n def slowid (x,y)\r\n   sleep 5\r\n   x\r\n end\r\n\r\n def memoize(&proc)\r\n   if not defined? @cache\r\n     @cache = Hash.new\r\n   end\r\n   a = Proc.new { |*x|\r\n     if @cache.has_key? x\r\n       @cache[x]\r\n     else\r\n       ret = proc.call *x\r\n       @cache[x] = ret\r\n     end\r\n   }\r\n end\r\n\r\n newslowid = memoize { |*x| slowid *x}\r\n puts (newslowid.call 3,2)\r\n puts (newslowid.call 3,2)\r\n');
INSERT INTO `revisions` VALUES (248,213,16,'2005-11-25 13:01:18','h1.  soluzione febbraio 2003 di gabriele renzi\r \n\r\n');
INSERT INTO `revisions` VALUES (249,214,16,'2005-11-25 13:01:18','h1. = Soluzione Febbraio 2003 di Gabriele Renzi\r \n\r\n def histogram(*list)\r\n  res=Hash.new\r\n  list.each do |el|\r\n   hist=String.new\r\n   break unless el.respond_to? :downto #commentabile\r\n   el.downto(1) { hist+=\"*\"}\r\n   res[el]=hist\r\n  end\r\n  return res\r\n end\r\n\r\n #test\r\n $v1=0\r\n $v2=2\r\n $v3=5\r\n a=histogram($v1,$v2,$v3)\r\n a.each do |k,v|\r\n  puts \"#{k}\\t:-#{v}\"\n');
INSERT INTO `revisions` VALUES (250,215,16,'2005-11-25 13:01:18','h1. = Soluzione Febbraio 2003 di Kirash\r \n\r\n def histogram(*arg)\r\n   j = 0\r\n   height = arg.max\r\n   str = Array.new(arg.max, \"\")\r\n   while height.nonzero?\r\n     arg.each_index {|i|\r\n       (arg[i] >= height)? str[j]+=\"#\" : str[j]+=\"\\s\"\r\n     }\r\n     str[j] += \"\\n\"\r\n     j += 1\r\n     height -= 1\r\n   end\r\n   return str\r\n end\r\n\r\n #test\r\n bar_chart = histogram(2,4,5,8,4,3)\r\n print bar_chart\r\n\r\n >>\r\n    #\r\n    #\r\n    #\r\n   ##\r\n  ####\r\n  #####\r\n ######\r\n ######\n');
INSERT INTO `revisions` VALUES (251,216,16,'2005-11-25 13:01:18','h1. = Soluzione Febbraio 2003 di Massimiliano Mirra\r \n\r\n def histogram(*list)\r\n   list.collect {|i| [i, \'*\' * i]}\r\n end\r\n\r\n fmt = \"%5d : %s\"\r\n\r\n histogram(10, 2, 4).each {|*values| puts fmt % values }\r\n\r\n # oppure:\r\n\r\n lines = histogram(10, 2, 4).collect {|*values| fmt % values }\r\n puts lines\n');
INSERT INTO `revisions` VALUES (252,217,16,'2005-11-25 13:01:18','h1. = Soluzione Marzo 2003 di Luigi Panzeri\r \n def format_number_list( *list )\r\n   start = prev = nil\r\n   list << nil \r\n   list.collect! { |cur|\r\n     if start == nil\r\n       start = cur\r\n     else\r\n       if cur != prev + 1 || cur == nil\r\n         ret = (start==prev ? \"#{start}\":\"#{start}-#{prev}\")\r\n         start = cur\r\n       end\r\n     end\r\n     prev = cur\r\n     ret\r\n   }\r\n   list.compact.join \", \"\r\n end\r\n\r\n def expand_number_list slist\r\n   slist.split(\", \").collect { |range|\r\n     eval(range.gsub(/([0-9]+)-([0-9]+)/, \'(\\1..\\2)\')).to_a\r\n   }\r\n end\n');
INSERT INTO `revisions` VALUES (253,218,16,'2005-11-25 13:01:18','h1.  SpezzarePathFile\r \n\r\n_ da perl cookbook 9.10_\r\n\r\n\r\nSupponete di avere in una stringa un percorso completo per un file, e di volere estrarre informazioni come la directory in cui si trova, ed il nome del dile senza il resto della string.\r\n\r\nSe state pensando ad usare una espressione regolare, dimenticatelo. Se questo e\' il file:\r\n >> file = \"C:/Programmi/OpenOffice.org1.0.1/share/template/italian/internal/html.sxw\"\r\n => \"C:/Programmi/OpenOffice.org1.0.1/share/template/italian/internal/html.sxw\"\r\n\r\nper ottenere il nome del solo file, pulito da tutto il resto del path, usate @File.basename()@:\r\n\r\n >> File.basename file\r\n => \"html.sxw\"\r\n\r\nSe volete solo la directory:\r\n >> File.dirname file\r\n => \"C:/Programmi/OpenOffice.org1.0.1/share/template/italian/internal\"\r\n\r\nSe volete l\'estensione del file:\r\n >> File.extname file\r\n => \".sxw\"\r\n\r\n\r\n');
INSERT INTO `revisions` VALUES (254,219,16,'2005-11-25 13:01:18','h1.  StatisticaParole\r \n\r\nSemplicemente, contiamo le diverse parole in un testo, e restituiamo una statistica sulla frequenza d\'uso. Notate che potete facilmente trasformare questo sistema in uno che conti i caratteri, per costruire quei comodi istogrammi di frequenza tanto cari ai programmi di decrittazione :) \r\n\r\nin sostanza:\r\n\r\nleggiamo il file:\r\n\r\n fd=File.read(\'i_promes.txt\')\r\n\r\nspezziamolo e mettiamolo in un array:\r\n\r\n ary=fd.split\r\n\r\ncreiamo un hash, e lo riempiamo di zeri:\r\n\r\n hsh=Hash.new(0)\r\n\r\npoi usiamo le parole come chiavi, incrementando ogni volta il valore:\r\n\r\n for parola in ary\r\n  hsh[parola]+=1\r\n end\r\n\r\nFinito :)\r\n\r\nA questo punto possiamo ordinare il tutto:\r\n\r\n  istogramma=hsh.to_a.sort_by {|elem| elem[1]}\r\n\r\nIn realta\', scoprirete che l\'ordinamento a\' dal meno frequente al piu\' frequente, ma il concetto non cambia :)\r\n\r\nOra, scoprirete come, nei promessi sposi, le dieci parole piu\' frequenti siano:\r\n\r\n >> puts istogramma.last(10)\r\n un\r\n 3132\r\n non\r\n 3144\r\n in\r\n 3313\r\n la\r\n 3385\r\n il\r\n 3604\r\n -\r\n 4213\r\n a\r\n 4460\r\n che\r\n 6010\r\n di\r\n 6248\r\n e\r\n 7009\r\n\r\n_finire, specificare accentate e unione righe e analisi una riga per volta_\n');
INSERT INTO `revisions` VALUES (255,220,16,'2005-11-25 13:01:18','h1.  Stato delle Traduzioni\r \n\r\nPer collaborare, sia come traduttore sia come revisore, rivolgetevi\r\nad un membro del gruppo.\r\n\r\n* [[Ruby User\'s Guide]]   _tradotto_\r\n* [[Programming Ruby]]    _in traduzione_\r\n* [[Ruby Language Reference Manual]]    _da tradurre_\r\n\r\n[[Progetti]]\n');
INSERT INTO `revisions` VALUES (256,221,16,'2005-11-25 13:01:18','h1.  Stefano Zamprogno\r \n\r\n');
INSERT INTO `revisions` VALUES (257,222,16,'2005-11-25 13:01:18','h1.  Gruppo Utenti Ruby Italia\r \nh1. == Benvenuti sulle pagine della prima comunita\' italiana di discussione su Ruby\r \n\r\n\r\nh1. = Descrizione del gruppo:\r \nIl gruppo nasce per\r\n*  Aiutare la diffusione del linguaggio di programmazione Ruby in Italia.\r\n*  Sostenere i progetti sviluppati in tale linguaggio.\r\n*  Riunire gli utenti in lingua italiana di Ruby.\r\n\r\nh1. = Mailing List e IRC\r \nLa mailing list del gruppo e\' [[ruby@ada2.unipv.it|URL:mailto://ruby@ada2.unipv.it]].\r\nPer iscriversi inviare una mail a\r\n[[ruby-request@ada2.unipv.it|URL:mailto://ruby-request@ada2.unipv.it?subject=subscribe]]\r\ncon l\'oggetto ((\'subscribe\')).\r\n\r\nL\'[[archivio|URL:http://ada2.unipv.it/pipermail/ruby]] della mailing list e\' l\r\niberamente consultabile.\r\n\r\n\r\nE\' inoltre possibile discutere su IRC sul canale #ruby-it su Freenode ( irc.freenode.net )\r\nh1. = Risorse\r \n*  [[Documentazione]]\r\n*  [[Links]]\r\n*  [[Progetti]]\r\n*  [[Ruby ed Emacs]]\r\n*  [[RubyQuiz del mese]]\r\n*  [[RubyHaiku]]\r\n*  [[CookBook]]\r\n*  [[Persone]]\n');
INSERT INTO `revisions` VALUES (258,223,16,'2005-11-25 13:01:18','h1.  Trovare Parole Ripetute\r \n\r\nAnche questo e\' semplice se usiamo le @Regexp@.\r\nAnzitutto dobbiamo sapere come individuare una parola.\r\n\r\nIl procedimento e\' leggermente differente da quello per individuare una semplice stringa. Infatti, abbiamo bisogno di usare il metacarattere  \"@\\b@\" per indicare, l\'inizio e la fine di una parola.\r\nFate attenzione a non confondere questo concetto con i simboli \"@^@\" e \"@$@\" che invece indicano l\'inizio e la fine di una _riga_\r\n\r\nEsempio:\r\n >> rgx=/\\bvia\\b/\r\n => /\\bvia\\b/\r\n >> \'via\'=~rgx\r\n => 1\r\n >> \'ferrovia\'=~rgx\r\n => nil\r\n\r\nAbbiamo imparato un trucco interessante. Ricordate che esiste anche  un opposto di  \"@\\b@\" , cioe\'  \"@\\B@\" , che indica un _non word boundary_, un punto in cui non c\'e un limite della parola.\r\n\r\nOra, passiamo alle _backreference_. In pratica, questi simboli ci permettono dire \"uno dei simboli gia\' trovati\".\r\nAd esempio:\r\n >> rgx=/(.)\\1/ # matcha ogni carattere, e poi lo stesso\r\n => /(.)\\1/\r\n >> \"ab\" =~ rgx\r\n => nil\r\n >> \"aa\" =~ rgx\r\n => 0\r\n >> \"x1x\" =~ rgx\r\n => nil\r\n >> \"x11x\" =~ rgx\r\n => 1\r\n\r\nIn pratica scriverete un \"@\\@\" e poi un numero che indica a quale gruppo si fa riferimento (in questo caso il primo).\r\nVediamo un esempio piu\' complicato:\r\n >> rgx=/(pi|po)\\1/\r\n => /(pi|po)\\1/\r\n >> \"pipi\" =~ rgx\r\n => 0\r\n >> \"popi\" =~ rgx\r\n => nil\r\n >> \"popo\" =~ rgx\r\n => 0\r\n\r\nOvviamente potete usare anche \"@\\2 \\3 \\4 \\n@\".\r\n\r\nA questo punto la nostra espressione regolare e\' semplice:\r\n\r\n >> rgx=/(\\b\\w+\\b)\\s+\\1/\r\n => /(\\b\\w+\\b)\\s+\\1/\r\n >> \"io vado a scuola\" =~ rgx\r\n => nil\r\n >> \"io vado a a scuola\" =~ rgx\r\n => 8\r\n >> \"io vado a scuola scuola\" =~ rgx\r\n => 10\r\n\r\n');
INSERT INTO `revisions` VALUES (259,224,16,'2005-11-25 13:01:18','h1.  UsareObjectSpace\r \n\r\nIl modulo @ObjectSpace@ e\' un modulo built-in in ruby, e come tale e\' documentato nel pickaxe (potete leggerlo [[qui|URL:http://www.rubycentral.com/book/ref_m_objectspace.html]] ) e tramite [[ri]].\r\n\r\nQuesto modulo permette di accedere come e\' evidente, allo _Spazio degli Oggetti_.\r\nL\'interprete ruby, infatti, in ogni momento deve sapere quali sono gli oggetti che esistono nel sistema. Ovviamente, visto che quest\'informazione esiste, perch&#233; non renderla disponibile agli utenti?\r\n\r\nL\'unico metodo che analizziamo in questa pagina e\'  @ObjectSpace#each_object()@\r\n\r\n\r\nQuesto metodo ci permette di rintracciare tutti gli oggetti esistenti appartenenti ad una classe stabilita da noi. \r\nFacciamo una prova con @IRB@:\r\n\r\n >> ObjectSpace.each_object(Bignum) {|x| puts x }\r\n => 0\r\n\r\nQuesto ci dice che non esistono oggetti di classe @Bignum@.\r\nPoiche\' @IRB@ e\' gia\' un programma complesso, se provate ad usare una classe come @String@ avrete un output enorme.\r\n\r\nFacciamo una prova con una nostra classe:\r\n\r\n >> class Mia\r\n >>  def initialize(a)\r\n >>   @a=a\r\n >>  end\r\n >> end\r\n => nil\r\n >> a=Mia.new 10\r\n => #<Mia:0x27d0228 @a=10>\r\n >> b=Mia.new 20\r\n => #<Mia:0x27ccc58 @a=20>\r\n >> ObjectSpace.each_object(Mia) {|x| puts x }\r\n #<Mia:0x27ccc58>\r\n #<Mia:0x27d0228>\r\n => 2\r\n\r\nE\' ovvio che avremmo potuto manipolare questi oggetti in modo molto piu\' complesso, ma per ora basta vedere il funzionamento :)\r\n\r\n');
INSERT INTO `revisions` VALUES (260,225,16,'2005-11-25 13:01:18','h1.  UsarePipeEFork\r \n\r\n_dal perl cookbook 16.10_\r\n\r\n\r\nDovendo far parlare due processi, la primitiva piu\' semplice ed utile e\' la pipe. Pipe significa _tubo_ ed in effetti e\' possibile fars un idea di due processi che sono attaccati tramite questo tubo, e dove uno parla l\'altro ascolta.\r\n\r\n\r\n\r\npotete trovare @pipe()@ dentro il modulo @IO@:\r\n\r\n lettore,scrittore = IO.pipe #crea un tubo, e restituisce \"i due estremi\"\r\n\r\nora, siccome @lettore@ e @scrittore@ sono due oggetti @IO@, possiamo leggerci e scriverci dentro. Ovviamente, pero\', dobbiamo avere due processi per poter comunicare :)\r\nIntroduciamo @fork()@ (notate che su windows non e\' implementata):\r\n@fork()@ non fa altro che duplicare il programma. I due processi continueranno ad eseguire in parallelo il codice. Ma allora come fare a sapere che e\' il padre e chi il figlio?\r\n\r\nBeh, si usa il valore di ritorno di @fork()@: nel padre sara\' il Process Id (pid) del figlio, mentre nel figlio sara\' soltanto @nil@. Quindi basta usare un @if@\r\n\r\n if fork() \r\n    codice del processo padre\r\n else \r\n    codice figlio\r\n end\r\n\r\ncome al solito, possiamo anche usare un blocco:\r\n fork {codice figlio}\r\n codice padre\r\n\r\nA questo punto, uno dei due scrivera\' nel tubo, e l\'altro leggera\', ad esempio:\r\n\r\n if fork \r\n   # non leggeremo, scriveremo:\r\n   lettore.close \r\n   # ogni cosa che leggiamo da console viene scritto sul processo2\r\n   scrittore.puts(gets) while true\r\n else\r\n   #non scriveremo, leggeremo\r\n   lettore.close\r\n   puts(\"messaggio dal processo padre:\"+lettore.gets) while true\r\n end\r\n\r\n\r\nOra, un \'ultima cosa da considerare: padre e figlio condividono la stessa pipe. Se uno dei due scrive il messaggio potra\' essere letto da entrambi. Ma ovviamente questo non e\' quello che volete, quindi cercate di ricordare di chiudere l\'oggetto lettore o scrittore in ognuno dei due processi. Un tubo funziona in una sola direzione.\r\n\r\nNota: per avere @fork()@ su windows potete creare il modulo @Win32::Process@ su rubyforge.\n');
INSERT INTO `revisions` VALUES (261,226,16,'2005-11-25 13:01:18','h1.  WordWrap\r \n\r\nIl word wrapping consiste nel mandare a capo una parola quando la linea in cui si trova\r\nsupera una certa lunghezza.\r\nUn modo un po\' _hackish_ per farlo:\r\n\r\n   def wordwrap(str, lunghezza )\r\n       str.gsub( /\\n/, \"\\n\\n\" ).gsub( /(.{1,#{lunghezza}})(\\s+|$)/, \"\\\\1\\n\" )\r\n   end\r\n   \r\n\r\nPossiamo migliorarlo un po\', ad esempio facendolo diventare un metodo di string, e\r\nmettendo un valore di default (un valore di default e\' sempre utile)\r\n\r\n   class String\r\n     def wordwrap( lung=72 )\r\n       gsub( /\\n/, \"\\n\\n\" ).gsub( /(.{1,#{lun}})(\\s+|$)/, \"\\\\1\\n\" )\r\n     end\r\n   end\r\n\r\nMa questo metodo rimane molto brutto e poco potente. \r\nFortunatemente ruby possiede un potente modulo, chiamato [[Text::Format|URL:http://raa.ruby-lang.org/list.rhtml?name=text-format]]\r\nche permette di effettuare molteplici operazioni sulle stringhe\r\n\r\nNel nostro caso si potrebbe fare\r\n\r\n   require \'text/format\'\r\n\r\n   formattatore = Text::Format.new {\r\n     @columns = 72\r\n   }\r\n   formattatore.format( stringa )\r\n\r\nQuale logica guida questo sistema? Nulla di speciale. @Text::Format.new@ accetta \r\nin input un blocco, e lo esegue al suo interno\r\n(tramite il metodo @instance_eval(&blocco)@.)\r\nEseguendolo imposta il valore della variabile @@columns@ a 68. \r\nQuando viene chiamato il metodo @format()@, viene usata questa variabile ( e molte altre, [[documentate|URL:http://www.halostatue.ca/ruby/Text__Format_doc/index.html]] insieme al modulo) per formattare la stringa. \r\n\r\nIn effetti se provate questo codice vi troverete una curiosa indentazione all\'inizio \r\ndel testo. Se volete eliminarla vi bastera\' scrivere  \r\n   Text::Format.new {\r\n     @columns = 68\r\n     @first_indent = 0\r\n   }\r\n\r\n\r\n');
INSERT INTO `revisions` VALUES (262,227,16,'2005-11-25 13:01:18','h1.  wxruby su windows\r \n\r\n[[wxWindows|URL:http://www.wxwindows.org]] e\' una libreria multipiattaforma per lo sviluppo di gui. E\' possibile usarla da ruby grazie a [[wxruby|URL:http://wxruby.rubyforge.org]].\r\nLa versione attuale e\' la 0.4. \r\n\r\nSe pero\' vi interessa e usate windows (e non disponete di un compilatore) potete scaricare da [[qui|URL:http://rubyforge.org/frs/download.php/794/wxruby-0.4.0-mswin.exe]] il pacchetto precompilato e gli esempi.\r\n\r\nLa libreria vera e propria di wxwindows dovete scaricarla a parte.\r\n\r\nh1. == UPDATE 27/07/04\r \ndisponibile [[qui|URL:http://rubyforge.org/frs/download.php/794/wxruby-0.4.0-mswin.exe]] la versione 0.4\n');

--
-- Table structure for table `schema_info`
--

CREATE TABLE `schema_info` (
  `version` int(11) default NULL
) ENGINE=MyISAM;

--
-- Dumping data for table `schema_info`
--

INSERT INTO `schema_info` VALUES (8);

